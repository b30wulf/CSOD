<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<link href="style.css" type="text/css" rel=stylesheet>
<title>Совет 9</title>
</head>
<body lang=RU link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">
<h2><a name="top">Совет 9. При всей надежности у </a>TCP есть и недостатки</h2>
<hr><div align="right"><a href="adv9.htm#p6">Вниз</a> | <a href="index.htm">Содержание</a> | <a href="adv8.htm">Назад</a> | <a href="adv10.htm">Далее</a></div>
<p style='text-align:justify;'>Как уже неоднократно отмечалось, TCP - надежный 
  протокол. Иногда эту мысль выражают так: «TCP гарантирует доставку отправленных 
  данных». Хотя эта формулировка часто встречается, ее следует признать исключительно 
  неудачной.</p>
<p style='text-align:justify;'>Предположим, что вы отсоединили хост от сети в 
  середине передачи данных. В таком случае TCP не сможет доставить оставшиеся 
  данные. А на практике происходят сбои в сети, аварии серверов, выключение машины 
  пользователями без Разрыва TCP-соединения. Все это мешает TCP доставить по назначению 
  данные, преданные приложением.</p>
<p style='text-align:justify;'>Но еще важнее психологическое воздействие фразы 
  о «гарантируемой TCP ставке» на излишне доверчивых сетевых программистов. Разумеется, 
  никто не считает, что TCP обладает магической способностью доставлять данные 
  получателю, невзирая на все препятствия. Вера в гарантированную доставку проявляется 
  в небрежном программировании и, в частности, в легкомысленном отношении к проверке 
  ошибок.</p>
<h3><a name="p1">Что такое надежность</a></h3>
<p style='text-align:justify;'>Прежде чем приступать к рассмотрению ошибок, с 
  которыми можно столкнутся при работе с TCP, обсудим, что понимается под надежностью 
  TCP. Если TCP нe гарантирует доставку всех данных, то что же он гарантирует? 
  Первый вопрос: кому дается гарантия? На рис. 2.18 показан поток данных от приложения 
  А вниз к стеку TCP/IP на хосте А, через несколько промежуточных маршрутизаторов, 
  вверх к стеку TCP/IP на хосте В и, наконец, к приложению В. Когда ТСР&nbsp;- 
  сегмент покидает уровень TCP на хосте А, он «обертывается» в IP-датаграмму для 
  передачи хосту на другой стороне. По пути он может пройти через несколько маршрутизаторов, 
  но, как видно из рис. 2.18, маршрутизаторы не имеют уровня TCP,они лишь переправляют 
  IР&nbsp;- датаграммы.</p>
<p align=center style='text-align:center;'> <img width=458 height=214
src="./img/image021.gif" v:shapes="_x0000_i1025"> </p>
<p align=center style='text-align:center;'>Рис. 2.18. Сеть с промежуточными маршрутизаторами</p>
<p style='text-align:justify;'><i>Примечание:</i> Некоторые маршрутизаторы в действительности 
  могут представлять собой компьютеры общего назначения, у которых есть полный 
  стек TCP/IP, но и в этом случае при выполнении функций маршрутизации не задействуются 
  ни уровень TCP, ни прикладной уровень.</p>
<p style='text-align:justify;'>Поскольку известно, что протокол IP ненадежен, 
  то первое место в тракте прохождения данных, в связи с которым имеет смысл говорить 
  о гарантиях, - это уровень TCP хоста В. Когда сегмент оказывается на этом уровне, 
  единственной, что можно сказать наверняка, - сегмент действительно прибыл. Он 
  может быть запорчен, оказаться дубликатом, прийти не по порядку или оказаться 
  неприемлемым еще по каким-то причинам. Обратите внимание, что отправляющий TCP 
  не может дать никаких гарантий по поводу сегментов, доставленных принимающему 
  TCP.</p>
<p style='text-align:justify;'>Однако принимающий TCP уже готов кое-что гарантировать 
  отправляющему TCP, а именно - любые данные, которые он подтвердил с помощью 
  сегмента АСК, а также все предшествующие данные, корректно дошли до уровня TCP. 
  Поэтому отправляющий TCP может отбросить их копии, которые у него хранятся. 
  Это не означает, что информация уже доставлена приложению или будет доставлена 
  в будущем. Например, принимающий хост может аварийно остановиться сразу после 
  посылки АСК, еще до того, как данные прочитаны приложением. Это стоит подчеркнуть 
  особо: единственное подтверждение приема данных, которое находите в ведении 
  TCP,&nbsp;- это вышеупомянутый сегмент АСК. Отправляющее приложение не может, 
  полагаясь только на TCP, утверждать, что данные были благополучно прочитаны 
  получателем. Как будет сказано далее, это одна из возможных ошибок при работе 
  с TCP, о которых разработчик должен знать.</p>
<p style='text-align:justify;'>Второе место, в связи с которым имеет смысл говорить 
  о гарантиях,&nbsp;- это само приложение В. Вы поняли, нет гарантий, что все 
  данные, отправленные приложением A, дойдут до приложения В. Единственное, что 
  TCP гарантирует приложению B,&nbsp;-доставленные данные пришли в правильном 
  порядке и не испорчены.</p>
<p style='text-align:justify;'><i>Примечание:</i> Неискаженностъ данных гарантируется 
  лишь тем, что ошибку можно обнаружить с помощью контрольной суммы. Поскольку 
  эта сумма представляет собой 16-разрядное дополнение до единицы суммы двойных 
  байтов, то она способна обнаружить пакет ошибок в 15 бит или менее [Plummer 
  1978]. Предполагая равномерное распределение данных, вероятность принятия TCP 
  ошибочного сегмента за правильный составляет не более 1 / (2^16 - 1). Однако 
  в работе [Stone et al. 1998] показано, что в реальных данных, встречающихся 
  в сегментах TCP, частота ошибок, не обнаруживаемых с помощью контрольной суммы, 
  при некоторых обстоятельствах может быть намного выше.</p>
<h3><a name="p2">Потенциальные ошибки</a></h3>
<p style='text-align:justify;'>Вы уже видели одну из потенциальных ошибок при 
  работе с TCP: не исключено, что подтвержденные TCP данные не дошли до приложения-получателя. 
  Как и большинство других таких ошибок, это довольно редкая ситуация, и, даже 
  если она встречается, последствия могут быть не очень печальными. Важно, чтобы 
  программист знал об этой неприятности и предусматривал защиту при возможном 
  нежелательном результате. Не думайте, что TCP обо всем позаботится сам, следует 
  подумать об устойчивости приложения.</p>
<p style='text-align:justify;'>Защита от упомянутой ошибки очевидна. Если приложению-отправителю 
  важно иметь информацию, что сообщение дошло до приложения-получателя, то получатель 
  должен сам подтвердить факт приема. Часто такое подтверждение присутствует неявно. 
  Например, если клиент запрашивает у сервера некоторые данные и сервер отвечает, 
  то сам ответ - это подтверждение получения запроса. Один из возможных способов 
  организации явных подтверждений обсуждается в совете 19.</p>
<p style='text-align:justify;'>Более сложный для клиента вопрос - что делать, 
  если сервер не подтверждает приема? Это в основном зависит от конкретного приложения, 
  поэтому готового Решения не существует. Однако стоит отметить, что повторная 
  посылка запроса не всегда годится; как говорилось в совете 8, вряд ли будет 
  правильно дважды переводить одну сумму со счета на счет. В системах управления 
  базами данных для решения такого рода проблем применяется протокол трехфазной 
  фиксации. Полный подход приемлем и для других приложений, гарантирующих, что 
  операция выполняется «не более одного раза». Один из примеров - службы параллельности, 
  фиксации и восстановления (concurrency, commitment, recovery - CCR) – это элемент 
  прикладного сервиса в протоколах OSI. Протокол CCR обсуждается в работе [Jain 
  and Agrawala 1993].</p>
<p style='text-align:justify;'>TCP&nbsp;- протокол сквозной передачи (end-to-end 
  protocol), то есть он стремится обеспечить надежный транспортный механизм между 
  двумя хостами одного ранга. Важно, однако, понимать, что конечные точки - это 
  уровни TCP на обоих хостах, а не приложения. Программы, которым нужны подтверждения 
  на прикладном уровне, должны самостоятельно это определить.</p>
<p style='text-align:justify;'>Рассмотрим некоторые типичные ошибки. Пока между 
  двумя хостами существует связь, TCP гарантирует доставку данных по порядку и 
  без искажений Ошибка может произойти только при разрыве связи. Из-за чего же 
  связь может разорваться? Есть три причины:</p>
<ul type=disc>
  <li style='text-align:justify;     '>постоянный или временный сбой в сети;</li>
  <li style='text-align:justify;     '>отказ принимающего приложения;</li>
  <li style='text-align:justify;     '>аварийный сбой самого хоста на принимающем 
    конце.</li>
</ul>
<p style='text-align:justify;'>Каждое из этих событий по-разному отражается на 
  приложении-отправителе.</p>
<h3><a name="p3">Сбой в сети</a></h3>
<p style='text-align:justify;'>Сбои в сети происходят по разным причинам: от потери 
  связи с маршрутизатором или отрезком опорной сети до выдергивания из разъема 
  кабеля локальной Ethernet-сети. Сбои, происходящие вне оконечных точек, обычно 
  временные, поскольку протоколы маршрутизации спроектированы так, чтобы обнаруживать 
  по­врежденные участки и обходить их.</p>
<p style='text-align:justify;'><i>Примечание:</i> Под оконечной точкой понимается 
  локальная сеть или хост, на котором работает приложение.</p>
<p style='text-align:justify;'>Если же ошибка возникает в оконечной точке, то 
  неисправность будет существовать, пока ее не устранят.</p>
<p style='text-align:justify;'>Если промежуточный маршрутизатор не посылает ICMP-сообщение 
  о том, что хост или сеть назначения недоступны, то ни само приложение, ни стек 
  TCP/IP на том же хосте не смогут немедленно узнать о сбое в сети (совет 10). 
  В этом случае у отправителя через некоторое время возникнет тайм-аут, и он повторно 
  отправит неподтвержденные сегменты. Это будет продолжаться, пока отправляющий 
  TCP не признает доставку невозможной, после чего он обрывает соединение и сообщает 
  об ошибке. В системе BSD это произойдет после 12 безуспешных попыток (примерно 
  9 мин). При наличии у TCP ожидающего запроса на чтение операция возвращает ошибку, 
  и переменная errno устанавливается в ETIMEDOUT. Если ожидающего запроса на чтение 
  нет, то следующая операция записи завершится ошибкой. При этом либо будет послан 
  сигнал SIGPIPE, либо (если этот сигнал перехвачен или игнорируется) в переменную 
  errno записано значение EPIPE.</p>
<p style='text-align:justify;'>Если промежуточный маршрутизатор не может переправить 
  далее IР-датаграмму, содержащую некоторый сегмент, то он посылает хосту&nbsp;- 
  отправителю ICMP-сообшение о том, что сеть или хост назначения недоступны. В 
  этом случае некоторые реализации возвращают в качестве кода ошибки значение 
  ENETUNREACH или EHOSTUNREACH</p>
<h3><a name="p4">Отказ приложения</a></h3>
<p style='text-align:justify;'>А теперь разберемся, что происходит, когда аварийно 
  или как-либо иначе завершается приложение на другом конце соединения. Прежде 
  всего следует понимать, что с точки зрения вашего приложения аварийное завершение 
  другого конца отличается от ситуации, когда приложение на том конце вызывает 
  функцию close (или closesocket, если речь идет о Windows), а затем exit. В обоих 
  случаях TCP на другом конце посылает вашему TCP сегмент FIN. FIN выступает в 
  роли признака конца файла и означает, что у отправившего его приложения нет 
  больше данных для вас. Это не значит, что приложение на другом конце завершилось 
  или не хочет принимать данные. Подробнее это рассмотрено в совете 16. Как приложение 
  уведомляется о приходе FIN (и уведомляется ли вообще), зависит от его действий 
  в этот момент. Для проработки возможных ситуаций напишем небольшую клиентскую 
  программу, которая читает строку из стандартного входа, посылает ее серверу, 
  читает ответ сервера и записывает его на стандартный выход. Исходный текст клиента 
  приведен в листинге 2.21.</p>
<p style='text-align:justify'>Листинг 2.21. TCP-клиент, который читает и выводит 
  строки</p>
<p style='text-align:justify'><a
href="source\tcprw.c">tcprw.с</a></p>
<p style='text-align:justify;'>1    #include &quot;etcp.h&quot;</p>
<p style='text-align:justify;'>2    int main( int argc, char **argv )</p>
<p style='text-align:justify;'>3    {</p>
<p style='text-align:justify;'>4    SOCKET s;</p>
<p style='text-align:justify;'>5    int rc;</p>
<p style='text-align:justify;'>6    int len;</p>
<p style='text-align:justify;'>7    char buf[ 120 ] ;</p>
<p style='text-align:justify;'>8    INIT();</p>
<p style='text-align:justify;'>9    s = tcp_client(  argv[ 1 ],   argv[ 2 ] );</p>
<div style='border:solid windowtext .5pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'> 
  <p class=MsoBodyText>10   while ( fgets( buf, sizeof( buf ), stdin ) != NULL 
    )</p>
</div>
<p style='text-align:justify;'>11   {</p>
<p style='text-align:justify;'>12     len = strlen ( buf );</p>
<p style='text-align:justify;'>13     rc = send( s, buf, len, 0 );</p>
<p style='text-align:justify;'>14     if ( rc &lt; 0 )</p>
<p style='text-align:justify;'>15      error( 1, errno, &quot;ошибка вызова send&quot; 
  );</p>
<p style='text-align:justify;'>16     rc = readline( s, buf, sizeof( buf ) );</p>
<p style='text-align:justify;'>17     if ( rc &lt; 0 )</p>
<p style='text-align:justify;'>18      error( 1, errno, &quot;ошибка вызова readline&quot; 
  );</p>
<p style='text-align:justify;'>19     else if ( rc == 0 )</p>
<p style='text-align:justify;'>20      error( 1, 0, &quot;сервер завершил работу\n&quot; 
  );</p>
<p style='text-align:justify;'>21     else</p>
<p style='text-align:justify;'>22      fputs( buf, stdout );</p>
<p style='text-align:justify;'>23   }</p>
<p style='text-align:justify;'>24   EXIT( 0 ) ;</p>
<p style='text-align:justify;'>25   }</p>
<p style='text-align:justify'>8-9 Инициализируем приложение как TCP-клиент и соединяемся 
  с указанными в командной строке сервером и портом.</p>
<p style='text-align:justify'>10-15 Читаем строки из стандартного входа и посылаем 
  их серверу, пока не встретится конец файла.</p>
<p style='text-align:justify'>16-20 После отправки данных серверу читается строка 
  ответа. Функция гeadline получает строку, считывая данные из сокета до символа 
  новой строки. Текст этой функции приведен в листинге 2.32 в совете 11. Если 
  readline обнаруживает ошибку или возвращает признак конца файла (совет 16), 
  то печатаем диагностическое сообщение и завершаем работу</p>
<p style='text-align:justify;'>22 В противном случае выводим строку на stdout.</p>
<p style='text-align:justify;'>Для тестирования клиента напишем сервер, который 
  читает в цикле строки поступающие от клиента, и возвращает сообщения о количестве 
  полученных строк. Для имитации задержки между приемом сообщения и отправкой 
  ответа сервер пять секунд «спит». Код сервера приведен в листинге 2.22.</p>
<p style='text-align:justify;'>Листинг 2.22. Сервер, подсчитывающий сообщения</p>
<p style='text-align:justify'><a
href="source\count.c">count.c</a></p>
<p style='text-align:justify;'>1    #include &quot;etcp.h&quot;</p>
<p style='text-align:justify;'>2    int main( int argc, char **argv )</p>
<p style='text-align:justify;'>3    {</p>
<p style='text-align:justify;'>4    SOCKET s;</p>
<p style='text-align:justify;'>5    SOCKET s1;</p>
<p style='text-align:justify;'>6    int rc;</p>
<p style='text-align:justify;'>7    int len;</p>
<p style='text-align:justify;'>8    int counter = 1;</p>
<p style='text-align:justify;'>9    char buf [ 120 ];</p>
<p style='text-align:justify;'>10   INIT();</p>
<p style='text-align:justify;'>11   s = tcp_server( NULL, argv[ 1 ] );</p>
<p style='text-align:justify;'>12   s1 = accept ( s, NULL, NULL );</p>
<p style='text-align:justify;'>13   if ( !isvalidsock( s1 ) )</p>
<p style='text-align:justify;'>14     error( 1, errno, &quot;ошибка вызова accept&quot; 
  );</p>
<p style='text-align:justify;'>15   while ( ( rc = readline( s1, buf, sizeof( 
  buf ) ) ) &gt; 0)</p>
<p style='text-align:justify;'>16   {</p>
<p style='text-align:justify;'>17     sleep ( 5 ) ;</p>
<p style='text-align:justify;'>18     len=sprintf(buf, &quot;получено сообщение 
  %d\n&quot;, counter++ );</p>
<p style='text-align:justify;'>19     rc = send( s1, buf, len, 0 );</p>
<p style='text-align:justify;'>20     if ( rc &lt; 0 )</p>
<p style='text-align:justify;'>21      error( 1, errno, &quot;ошибка вызова send&quot; 
  );</p>
<p style='text-align:justify;'>22   }</p>
<p style='text-align:justify;'>23   EXIT ( 0 );</p>
<p style='text-align:justify;'>24   }</p>
<p style='text-align:justify;'>Чтобы увидеть, что происходит при крахе сервера, 
  сначала запустим сервер и клиент в различных окнах на машине bsd.</p>
<p style='text-align:justify'>bsd: $ tcprw localhost 9000</p>
<p style='text-align:justify'>hello</p>
<p style='text-align:justify'>получено сообщение 1 Это печатается после пятисекундной 
  задержки</p>
<div style='border:solid windowtext .5pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'> 
  <p class=MsoBodyText>                     Здесь сервер был остановлен.</p>
</div>
<p style='text-align:justify'>hello again</p>
<p style='text-align:justify'>tcprw: ошибка вызова readline: Connection reset 
  by peer (54)</p>
<p style='text-align:justify'>bsd: $</p>
<p style='text-align:justify;'>Серверу посылается одно сообщение, и через 5 с 
  приходит ожидаемый ответ. Останавливаете серверный процесс, моделируя аварийный 
  отказ. На стороне клиента ничего не происходит. Клиент блокирован в вызове fgets, 
  а протокол TCP не может передать клиенту информацию о том, что от другого конца 
  получен конец файла (FIN). Если ничего не делать, то клиент так и останется 
  блокированным в ожидании ввода и не узнает о завершении сеанса сервера.</p>
<p style='text-align:justify;'>Затем вводите новую строку. Клиент немедленно завершает 
  работу с сообщением о том' что хост сервера сбросил соединение. Вот что произошло: 
  функция fgets вернула управление клиенту, которому все еще неизвестно о приходе 
  признака конца файла от сервера. Поскольку ничто не мешает приложению посылать 
  данные после прихода FIN, TCP клиента попытался послать серверу вторую строку. 
  Когда TCP сервера получил эту строку, он послал в ответ сегмент RST (сброс), 
  поскольку соединения уже не существует,&nbsp;- сервер завершил сеанс. Когда 
  клиент вызывает readline, ядро возвращает ему код ошибки ECONNRESET, сообщая 
  тем самым о получении извещения о сбросе. На рис. 2.19 показана хронологическая 
  последовательность этих событий.</p>
<p align=center style='text-align:center;'> <img border=0 width=371 height=333
src="./img/image022.gif" v:shapes="_x0000_i1027"> </p>
<p align=center style='text-align:center;'>Рис. 2.19. Хронологическая последовательность 
  событий при крахе сервера</p>
<p style='text-align:justify;'>А теперь рассмотрим ситуацию, когда сервер «падает», 
  не успев закончить обработку запроса и ответить. Снова запустите сервер и клиент 
  в разных окнах на машине bsd.</p>
<p style='text-align:justify'>bsd = $ tcprw  localhoBt 9000</p>
<p style='text-align:justify'>hello</p>
<p style='text-align:justify;'>Здесь сервер был остановлен.</p>
<p style='text-align:justify;'>tcprw: сервер завершил работу</p>
<p style='text-align:justify;'>bsd: $</p>
<p style='text-align:justify;'>Посылаете строку серверу, а затем прерываете его 
  работу до завершения вызова sleep. Тем самым имитируется крах сервера до завершения 
  обработки запроса. На этот раз клиент немедленно получает сообщение об ошибке, 
  говорящее о завершении сервера. В этом примере клиент в момент прихода FIN блокирован 
  в вызове readline и TCP может уведомить readline сразу, как только будет получен 
  конец файла. Хронологическая последовательность этих событий изображена на рис. 
  2.20</p>
<p align=center style='text-align:center;'> <img border=0 width=329 height=184
src="./img/image023.gif" v:shapes="_x0000_i1026"> </p>
<p align=center style='text-align:center;'>Рис. 2.20. Крах сервера в момент, когда 
  в клиенте происходит чтение</p>
<p style='text-align:justify;'>Ошибка также может произойти, если игнорировать 
  извещение о сбросе соединения и продолжать посылать данные. Чтобы промоделировать 
  эту ситуацию, следует изменить обращение к функции error после readline&nbsp;- 
  вывести диагностическое сообщение, но не завершаться. Для этого достаточно вместо 
  строки 17 в листинге 2.21 написать</p>
<p style='text-align:justify;'>error( 0, errno, &quot;ошибка при вызове readline&quot; 
  );</p>
<p style='text-align:justify;'>Теперь еще раз надо прогнать тест:</p>
<p style='text-align:justify;'>bsd: $ tcprw localhost 9000</p>
<p style='text-align:justify;'>hello.</p>
<p style='text-align:justify;'>получено сообщение 1</p>
<p style='text-align:justify;'>Здесь сервер был остановлен.</p>
<p style='text-align:justify;'>hello again</p>
<p style='text-align:justify'>tcprw: ошибка вызова readline: Connection reset 
  by peer (54)</p>
<p style='text-align:justify;'>Клиент игнорирует ошибку, но</p>
<p style='text-align:justify;'>TCP уже разорвал соединение.</p>
<p style='text-align:justify'>hello for the last time</p>
<p style='text-align:justify;'>Broken pipe   Клиент получает сигнал SIGPlPE</p>
<p style='text-align:justify;'>и завершает работу.</p>
<p style='text-align:justify'>bsd: $</p>
<p style='text-align:justify;'>Когда вводится вторая строка, клиент, как и раньше, 
  немедленно извещает ошибке (соединение сброшено сервером), но не завершает сеанс. 
  Он еще раз обращается к fgets, чтобы получить очередную строку для отправки 
  серверу стоит внести эту строку, как клиент тут же прекращает работу, и командный 
  интерпретатор сообщает, что выполнение было прервано сигналом SIGPIPE. В этом 
  случае при втором обращении к send, как и прежде, TCP послал RST, но вы не обратили 
  на него внимания. Однако после получения RST клиентский ТСP разорвал соединение, 
  поэтому при попытке отправить третью строку он немедленно завершает клиента, 
  посылая ему сигнал SIGPIPE. Хронология такая же как на рис. 2.19. Разница лишь 
  в том, что клиент «падает» при попытке записи, а не чтения.</p>
<p style='text-align:justify;'>Правильно спроектированное приложение, конечно, 
  не игнорирует ошибки, такая ситуация может иметь место и в корректно написанных 
  программах. Предположим, что приложение выполняет подряд несколько операций 
  записи без промежуточного чтения- Типичный пример - FTP. Если приложение на 
  другом конце «падает», то TCP посылает сегмент FIN. Поскольку данная программа 
  только пишет, но не читает, в ней не содержится информация о получении этого 
  FIN. При отправке следующего сегмента TCP на другом конце вернет RST. А в программе 
  опять не будет никаких сведений об этом, так как ожидающей операции чтения нет. 
  При второй попытке записи после краха отвечающего конца программа получит сигнал 
  SIGPIPE, если этот сигнал перехвачен или игнорируется&nbsp;- код ошибки EPIPE.</p>
<p style='text-align:justify;'>Такое поведение вполне типично для приложений, 
  выполняющих многократную запись без чтения, поэтому надо отчетливо представлять 
  себе последствия. Приложение уведомляется только после второй операции отправки 
  данных завершившемуся партнеру. Но, так как предшествующая операция привела 
  к сбросу соединения, посланные ей данные были потеряны.</p>
<p style='text-align:justify;'>Поведение зависит от соотношения времен. Например, 
  если снова прогнать первый тест, запустив сервер на машине spare, а клиента&nbsp;- 
  на машине bsd, то получается следующее:</p>
<p style='text-align:justify'>bsd: $ tcprw localhost 9000</p>
<p style='text-align:justify'>hello</p>
<p style='text-align:justify'>получено сообщение 1    Это печатается после пятисекундной</p>
<p style='text-align:justify;'>задержки.</p>
<p style='text-align:justify;'>Здесь сервер был остановлен.</p>
<p style='text-align:justify'>hello again</p>
<p style='text-align:justify'>tcprw: сервер завершил работу</p>
<p style='text-align:justify'>bsd: $</p>
<p style='text-align:justify;'>На этот раз клиент обнаружил конец файла, посланный 
  в результате остановки сервера. RST по-прежнему генерируется при отправке второй 
  строки, но из-за задержек в сети клиент успевает вызвать readline и обнаружить 
  конец файла еще до того, как хост bsd получит RST. Если вставить между строками 
  14 и 15 в листинге 2.21 строчку</p>
<p style='text-align:justify'>sleep( 1 );</p>
<p style='text-align:justify'>с целью имитировать обработку на клиенте или загруженность 
  системы, то получится тот же результат, что и при запуске клиента и сервера 
  на одной машине.</p>
<h3><a name="p5">Kр</a>ax хоста на другом конце соединения</h3>
<p style='text-align:justify;'>Последняя ошибка, которую следует рассмотреть, 
  - это аварийный останов хоста на другом конце. Ситуация отличается от краха 
  хоста, поскольку TCP на другом конце не может с помощью сегмента FIN проинформировать 
  программу о то, что ее партнер уже не работает.</p>
<p style='text-align:justify;'>Пока хост на другом конце не перезагрузят, ситуация 
  будет выглядеть как сбой в сети&nbsp;- TCP удаленного хоста не отвечает. Как 
  и при сбое в сети, TCP продолжает повторно передавать неподтвержденные сегменты. 
  Но в конце концов, если удаленный хост так и не перезагрузится, то TCP вернет 
  приложению код ошибки ETIMEDOUT.</p>
<p style='text-align:justify;'>А что произойдет, если удаленный хост перезагрузится 
  до того, как TCP Прекратит попытки и разорвет соединение? Тогда повторно передаваемые 
  вами сегменты дойдут до перезагрузившегося хоста, в котором нет никакой информации 
  о старых соединениях. В таком случае спецификация TCP [Postel 1981b] требует, 
  чтобы принимающий хост послал отправителю RST. В результате отправитель оборвет 
  соединение, и приложение либо получит код ошибки ECONNRESET (если есть ожидающее 
  чтение), либо следующая операция записи закончится сигналов SIGPIPE или ошибкой 
  EPIPE.</p>
<h3><a name="p6">Резюме</a></h3>
<p style='text-align:justify;'>В этом разделе дано объяснение понятию «надежность 
  TCP». Вы узнали, что не существует гарантированной доставки, и при работе с 
  TCP могут встретиться разнообразные ошибки. Ни одна из этих ошибок не фатальна, 
  но вы должны быть готовы к их обработке.</p>
<hr><div align="right"><a href="adv9.htm#top">Вверх</a> | <a href="index.htm">Содержание</a> | <a href="adv8.htm">Назад</a> | <a href="adv10.htm">Далее</a></div>
</body>
</html>
