<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<link href="style.css" type="text/css" rel=stylesheet>
<title>Совет 24</title>
</head>
<body lang=RU link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">
<h2><a name="top">Совет 24. По возможности пишите один большой блок 
  вместо нескольких маленьких</a></h2>
<hr><div align="right"><a href="adv24.htm#p3">Вниз</a> | <a href="index.htm">Содержание</a> | <a href="adv23.htm">Назад</a> | <a href="adv25.htm">Далее</a></div>
<p style='text-align:justify;'>Для этой рекомендации есть несколько причин. Первая 
  очевидна и уже обсуждалась выше: каждое обращение к функциям записи (write, 
  send и т.д.) требует, по меньшей мере, двух контекстных переключений, а это 
  довольно дорогая операция. С другой стороны, многократные операции записи (если 
  не считать случаев типа записи по одному байту) не требуют заметных накладных 
  расходов в прило­жении. Таким образом, совет избегать лишних системных вызовов&nbsp;- 
  это, скорее, «правила хорошего тона», а не острая необходимость.</p>
<p style='text-align:justify;'>Есть, однако, и более серьезная причина избегать 
  многократной записи мел­ких блоков - эффект алгоритма Нейгла. Этот алгоритм 
  кратко рассмотрен в совете 15. Теперь изучим его взаимодействие с приложениями 
  более детально. Если не принимать в расчет алгоритм Нейгла, то это может привести 
  к неправильному решению задач, так или иначе связанных с ним, и существенному 
  снижению производительности некоторых приложений.</p>
<p style='text-align:justify;'>К сожалению, алгоритм Нейгла, равно как и состояние 
  TIME-WAIT, многие программисты понимают недостаточно хорошо. Далее будут рассмотрены 
  причины появления этого алгоритма, способы его отключения и предложены эффективные 
  решения, которые обеспечивают хорошую производительность приложению, оказывая 
  негативного влияния на сеть в целом.</p>
<p style='text-align:justify;'>Алгоритм был впервые предложен в 1984 году Джоном 
  Нейглом (RFC 896 [Nagle 1984]) для решения проблем производительности таких 
  программ, как telnet и ей подобных. Обычно эти программы посылают каждое нажатие 
  клавиши в отдельном сегменте, что приводит к засорению сети множеством крохотных 
  датаграмм (tinygrams). Если принять во внимание, что минимальный размер ТСР-сегмента 
  (без данных) равен 40 байт, то накладные расходы при посылке одного байта в 
  сегменте достигают 4000%. Но важнее то, что увеличивается число пакетов в сети. 
  А это приводит к перегрузке и необходимости повторной передачи, из-за чего перегрузка 
  еще более увеличивается. В неблагоприятном случае в сети находится несколько 
  копий каждого сегмента, и пропускная способность резко снижается по сравнению 
  с номинальной.</p>
<p style='text-align:justify;'>Соединение считается простаивающим, если в нем 
  нет неподтвержденных данных (то есть хост на другом конце подтвердил все отправленные 
  ему данные). В первоначальном виде алгоритм Нейгла должен был предотвращать 
  описанные выше проблемы. При этом новые данные от приложения не посылаются до 
  тех пор, пока соединение не перейдет в состояние простоя. В результате в соединении 
  не может находиться более одного небольшого неподтвержденного сегмента.</p>
<p style='text-align:justify;'>Процедура, описанная в RFC 1122 [Braden 1989] несколько 
  ослабляет это требование, разрешая посылать данные, если их хватает для заполнения 
  целого сегмента. Иными словами, если можно послать не менее MSS байт, то это 
  разрешено, даже если соединение не простаивает. Заметьте, что условие Нейгла 
  при этом по-прежнему выполняется: в соединении находится не более одного небольшого 
  неподтвержденного сегмента.</p>
<p style='text-align:justify;'>Многие реализации не следуют этому правилу буквально, 
  применяя алгоритм Нейгла не к сегментам, а к операциям записи. Чтобы понять, 
  в чем разница, предположим, что MSS составляет 1460 байт, приложение записывает 
  1600 байт, в окнах приема и передачи свободно, по меньшей мере, 2000 байт и 
  соединение простаивает. Если применить алгоритм Нейгла к сегментам, то следует 
  послать 1460 байт, а затем ждать подтверждения перед отправкой следующих 140 
  байт – алгоритм Нейгла применяется при посылке каждого сегмента. Если же использовать 
  алгоритм Нейгла к операциям записи, то следует послать 1460 байт, а вслед за 
  ними еще 140 байт - алгоритм применяется только тогда, когда приложение передаете 
  TCP новые данные для доставки.</p>
<p style='text-align:justify;'>Алгоритм Нейгла работает хорошо и не дает приложениям 
  забить сеть крохотными пакетами. В большинстве случае производительность не 
  хуже, чем в реализации TCP, в которой алгоритм Нейгла отсутствует.</p>
<p style='text-align:justify;'><i>Примечание:</i> Представьте, например, приложение, 
  которое передает ТСP один байт каждые 200 мс. Если период кругового обращения 
  (RTT, для соединения равен одной секунде, то TCP без алгоритма Нейгла будет 
  посылать пять сегментов в секунду с накладными расходами 4000%. При наличии 
  этого алгоритма первый байт отсылается сразу, а следующие четыре байта, поступившие 
  от приложения, будут задержаны, пока не придет подтверждены на первый сегмент. 
  Тогда все четыре байта посылаются сразу. Таким образом, вместо пяти сегментов 
  послано только два, за счет чего накладные расходы уменьшились до 1600% при 
  сохранении той же скорости 5 байт/с.</p>
<p style='text-align:justify;'>К сожалению, алгоритм Нейгла может плохо взаимодействовать 
  с другой, добавленной позднее возможностью TCP - отложенным подтверждением.</p>
<p style='text-align:justify;'>Когда прибывает сегмент от удаленного хоста, TCP 
  задерживает отправку АСК в надежде, что приложение скоро ответит на только что 
  полученные данные. Поэтому АСК можно будет объединить с данными. Традиционно 
  в системах, производных от BSD, величина задержки составляет 200 мс.</p>
<p style='text-align:justify;'><i>Примечание:</i> В RFC 1122 не говорится о сроке 
  задержки, требуется лишь, чтобы она была не больше 500 мс. Рекомендуется также 
  подтверждать, по крайней мере, каждый второй сегмент.</p>
<p style='text-align:justify;'>Отложенное подтверждение служит той же цели, что 
  и алгоритм Нейгла&nbsp;- уменьшить число повторно передаваемых сегментов.</p>
<p class=MsoBodyTextIndent2>Принцип совместной работы этих механизмов рассмотрим 
  на примере типичного сеанса «запрос/ответ». Как показано на рис. 3.12, клиент 
  посылает короткий запрос серверу, ждет ответа и посылает следующий запрос.</p>
<p style='text-align:justify;'>Заметьте, что алгоритм Нейгла не применяется, поскольку 
  клиент не посылает новый сегмент, не дождавшись ответа на предыдущий запрос, 
  вместе с которым приходит и АСК. На стороне сервера задержка подтверждения дает 
  серверу время ответить. Поэтому для каждой пары запрос/ответ нужно всего два 
  сегмента. Если через RTT обозначить период кругового обращения сегмента, а через 
  Тp - время, необходимое серверу для обработки запроса и отправки ответа (в миллисекундах), 
  то на каждую пару запрос/ответ уйдет RTT + Тp мс.</p>
<p style='text-align:justify;'>А теперь предположим, что клиент посылает свой 
  запрос в виде двух последовательных операций записи. Часто причина в том, что 
  запрос состоит из заголовка, за которым следуют данные. Например, клиент, который 
  посылает серверу запросы переменной длины, может сначала послать длину запроса, 
  а потом сам запрос.</p>
<p style='text-align:justify;'><i>Примечание: </i>Пример такого типа изображен 
  на рис. 2.17, но там были приняты меры для отправки длины и данных в составе 
  одного сегмента.</p>
<p style='text-align:justify;'>На рис. 3.13. показан поток данных.</p>
<p align=center style='text-align:center;'> <img width=565 height=236
src="./img/image036.gif" v:shapes="_x0000_i1025"> </p>
<table border=0 cellspacing=0 cellpadding=0>
  <tr> 
    <td width=338 valign=top class="Normal"> 
      <p align=center style='text-align:center;'>Рис. 3.12. Поток данных из одиночных 
        сегментов сеанса «запрос.ответ»</p>
    </td>
    <td width=338 valign=top class="Normal"> 
      <p align=center style='text-align:center;'>Рис. 3.13. Взаимодействие алгоритма</p>
      <p align=center style='text-align:center;'>Нейгла и отложенного подтверждения</p>
    </td>
  </tr>
</table>
<p class=MsoBodyTextIndent2>На этот раз алгоритмы взаимодействуют так, что число 
  сегментов, посланных на каждую пару запрос/ответ, удваивается, и это вносит 
  заметную задержку.</p>
<p style='text-align:justify;'>Данные из первой части запроса посылаются немедленно, 
  но алгоритм Нейгла не дает послать вторую часть. Когда серверное приложение 
  получает первую часть запроса, оно не может ответить, так как запрос целиком 
  еще не пришел. Это значит, что перед посылкой подтверждения на первую часть 
  должен истечь тайм-аут установленный таймером отложенного подтверждения. Таким 
  образом, алгоритмы Нейгла и отложенного подтверждения блокируют друг друга: 
  алгоритм Нейгла мешает отправке второй части запроса, пока не придет подтверждение 
  на первую а алгоритм отложенного подтверждения не дает послать АСК, пока не 
  сработает таймер, поскольку сервер ждет вторую часть. Теперь для каждой пары 
  запрос/ответ нужно четыре сегмента и 2 X RTT + Тp + 200 мс. В результате за 
  секунду можно обработать не более пяти пар запрос/ответ, даже если забыть о 
  времени обработки запроса сервером и о периоде кругового обращения.</p>
<p style='text-align:justify;'><i>Примечание</i>: Для многих систем это изложение 
  чрезмерно упрощенное. Например, системы, производные от BSD, каждые 200 мс проверяют 
  все соединения, для которых подтверждение было отложено. При этом АСК посылается 
  независимо от того, сколько времен прошло в действительности. Это означает, 
  что реальная задержка может составлять от 0 до 200 мс, в среднем 100 мс. Однако 
  часто задержка достигает 200мс из-за «фазового эффекта состоящего в том, что 
  ожидание прерывается следующим тактом таймера через 200 мс. Первый же ответ 
  синхронизирует ответы с тактовым генератором. Хороший пример такого поведения 
  см. в работе [Minshall et al. 1999]. I</p>
<p class=MsoBodyTextIndent2>Последний пример показывает причину проблемы: клиент 
  выполняет последовательность операций «запись, запись, чтение». Любая такая 
  последовательность приводит к нежелательной интерференции между алгоритмом Нейгла 
  и алгоритмом отложенного подтверждения, поэтому ее следует избегать. Иными словами 
  приложение, записывающее небольшие блоки, будет страдать всякий раз, когда хост 
  на другом конце сразу не отвечает.</p>
<p style='text-align:justify;'>Представьте приложение, которое занимается сбором 
  данных и каждые 50 мс посылает серверу одно целое число. Если сервер не отвечает 
  на эти сообщения, а просто записывает данные в журнал для последующего анализа, 
  то будет наблюдаться такая же интерференция. Клиент, пославший одно целое, блокируется 
  алгоритмом Нейгла, а затем алгоритмом отложенного подтверждения, например на 
  200 мс, после чего посылает по четыре целых каждые 200 мс.</p>
<h3><a name="p1">Отключение алгоритма Нейгла</a></h3>
<p style='text-align:justify;'>Поскольку сервер из последнего примера записывал 
  в журнал полученные данные, взаимодействие алгоритмов Нейгла и отложенного подтверждение 
  не принесло вреда и, по сути, уменьшило общее число пакетов в четыре раза. Допустим 
  что клиент посылает серверу серию результатов измерения температуры, и сервер 
  должен отреагировать в течение 100 мс, если показания выходят за пределы допустимого 
  диапазона. В этом случае задержка на 200 мс, вызванная интерференцией алгоритмов, 
  уже нетерпима, и ее надо устранить.</p>
<p style='text-align:justify;'>Хорошо, что RFC 1122 требует наличия метода, отключающего 
  алгоритм Нейгла. Пример с клиентом, следящим за температурой, - это один из 
  случаев, когда такое отключение необходимо. Менее драматичный, но более реалистичный 
  пример относится к системе X-Window, работающей на платформе UNIX. Поскольку 
  X использует протокол TCP для общения между дисплеем (сервером) и приложением 
  (клиентом), Х-сервер должен доставлять информацию о действиях пользо­вателя 
  (перемещении курсора мыши) Х-клиенту без задержек, вносимых алгоритмом Нейгла.</p>
<p style='text-align:justify;'>В API сокетов можно отключить алгоритм Нейгла с 
  помощью установки опции сокета TCP_NODELAY.</p>
<p style='text-align:justify'>const  int  on =  1</p>
<p style='text-align:justify'>setsockopt( s, IPPROTO_TCP, TCP_NODELAY, &amp;on, 
  sizeof( on ) );</p>
<p style='text-align:justify;'>Но возможность отключения алгоритма Нейгла вовсе 
  не означает, что это обязательно делать. Приложений, имеющих реальные основания 
  отключать алгоритм, значительно меньше, чем тех, которые это делают без причины. 
  Причина, по которой программисты с пугающей регулярностью сталкиваются с классической 
  проблемой интерференции между алгоритмами Нейгла и отложенного подтверждения, 
  в том, что делают много мелких операций записи вместо одной большой. Потом они 
  замечают, что производительность приложений намного хуже, чем ожи­далось, и 
  спрашивают, что делать. И кто-нибудь обязательно ответит: «Это все алгоритм 
  Нейгла. Отключите его!». Нет нужды говорить, что после отключения этого алгоритма 
  проблема производительности действительно исчезает. Только за это приходится 
  расплачиваться увеличением числа крохотных пакетов в сети. Если так работают 
  многие приложения или, что еще хуже, алгоритм Нейгла отключен по умолчанию, 
  то возрастет нагрузка сети. В худшем случае это может привести к полному затору.</p>
<h3><a name="p2">Запись со сбором</a></h3>
<p style='text-align:justify;'>Как видите, существуют приложения, которые, действительно, 
  должны отключать алгоритм Нейгла, но в основном это делается из-за проблем с 
  производительностью, причина которых в отправке логически связанных данных серией 
  из Дельных операций записи. Есть много способов собрать данные, чтобы послать 
  вместе. Наконец всегда можно скопировать различные порции данных в один буфер, 
  которые потом и передать операции записи. Но, как объясняется в совете 26 к 
  такому методу следует прибегать в крайнем случае. Иногда можно организовать 
  хранение данных в одном месте, как и сделано в листинге 2.15. Чаще однако иные 
  находятся в нескольких несмежных буферах, а хотелось бы послать их одной операцией 
  записи.</p>
<p style='text-align:justify;'>Для этого и в UNIX, и в Winsock предусмотрен некоторый 
  способ. К сожалению, эти способы немного отличаются. В UNIX есть системный вызов 
  writev и парный ему вызов readv. При использовании writev вы задаете список 
  буферов, из которых должны собираться данные. Это решает исходную задачу: можно 
  размещать данные в нескольких буферах, а записывать их одной операцией, исключив 
  тем самым интерференцию между алгоритмами Нейгла и отложенного подтверждения.</p>
<div style='border:solid windowtext .5pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'> 
  <p style='text-align:justify;border:none;padding:0cm;'>#include &lt;sys/uio.h&gt;</p>
  <p style='text-align:justify;border:none;padding:0cm;'>ssize_t writev (int fd, 
    const struct iovec *iov, int cnt);</p>
  <p style='text-align:justify;border:none;padding:0cm;'>ssize_t readv(int fd, 
    const struct iovec *iov, int cnt);</p>
  <p class=MsoBodyText>Возвращаемое значение: число переданных байт или -1 в случае 
    ошибки.</p>
</div>
<p style='text-align:justify;'>Параметр iov- это указатель на массив структур 
  iovec, в которых хранятся указатели на буферы данных и размеры этих буферов:</p>
<p style='text-align:justify'>struct iovec {</p>
<p style='text-align:justify'> char *iov_base; /* Адрес начала буфера. */</p>
<p style='text-align:justify'> size_t iov_len; /* Длина буфера. */</p>
<p style='text-align:justify'>};</p>
<p style='text-align:justify;'><i>Примечание:</i> Это определение взято из системы 
  FreeBSD. Теперь во многих системах адрес начала буфера определяется так:</p>
<p style='text-align:justify'>void *iov_base;  /* адрес  начала  буфера */</p>
<p style='text-align:justify;'>Третий параметр, cnt - это число структур iovec 
  в массиве (иными словами, количество буферов).</p>
<p style='text-align:justify;'>У вызовов writev и readv практически общий интерфейс. 
  Их можно использовать для любых файловых дескрипторов, а не только для сокетов.</p>
<p style='text-align:justify;'>Чтобы это понять, следует переписать клиент (листинг 
  3.23), работающий с записями переменной длины (листинг 2.15), с использованием 
  writev.</p>
<p style='text-align:justify'>Листинг 3.23. Клиент, посылающий записи переменной 
  длины с помощью writev</p>
<p style='text-align:justify'><a href="source\vrcv.c">vrcv.с</a></p>
<p style='text-align:justify;'>1    #include &quot;etcp.h&quot;</p>
<p style='text-align:justify;'>2    #include &lt;sys/uio.h&gt;</p>
<p style='text-align:justify;'>3   int main( int  argc,   char  **argv)</p>
<p style='text-align:justify;'>4   {</p>
<p style='text-align:justify;'>5   SOCKET s;</p>
<p style='text-align:justify;'>6   int n;</p>
<p style='text-align:justify;'>7   char  buf[128];</p>
<p style='text-align:justify;'>8   struct   iovec   iov[ 2 ];</p>
<p style='text-align:justify;'>9    INIT();</p>
<p style='text-align:justify;'>10   s = tcp_client( argv[ 1 ], argv[ 2 ] ) ;</p>
<p style='text-align:justify;'>11   iov[ 0 ].iov_base = ( char * )&amp;n;</p>
<p style='text-align:justify;'>12   iov[ 0 ].iov_len = sizeof( n ) ;</p>
<p style='text-align:justify;'>13   iov[ 1 ].iov_base = buf;</p>
<p style='text-align:justify;'>14   while ( fgets( buf, sizeof( buf ), stdin ) 
  != NULL )</p>
<p style='text-align:justify;'>15   {</p>
<p style='text-align:justify;'>16     iov[ 1 ].iov_len = strlent buf );</p>
<p style='text-align:justify;'>17     n = htonl ( iov[ 1 ].iov_len ) ;</p>
<p style='text-align:justify;'>18     if ( writev( s, iov, 2 ) &lt; 0 )</p>
<p style='text-align:justify;'>19      error( 1, errno, &quot;ошибка вызова writev&quot; 
  );</p>
<p style='text-align:justify;'>20   }</p>
<p style='text-align:justify;'>21   EXIT( 0 ) ;</p>
<p style='text-align:justify;'>22   }</p>
<p><i>Инициализация</i></p>
<p style='text-align:justify'>9-13 Выполнив обычную инициализацию клиента, формируем 
  массив iov. Поскольку в прототипе writev имеется спецификатор const для структур, 
  на которые указывает параметр iov, то есть гарантия, что массив iov не будет 
  изменен внутри writev, так что большую часть параметров можно задавать вне цикла 
  while.</p>
<p style='text-align:justify'><i>Цикл обработки событий</i></p>
<p style='text-align:justify'>14-20 Вызываем fgets для чтения одной строки из 
  стандартного ввода, вычисляем ее длину и записываем в поле структуры из массива 
  iov. Кроме того, длина преобразуется в сетевой порядок байт и сохраняется в 
  переменной n.</p>
<p style='text-align:justify;'>Если запустить сервер vrs (совет 6) и вместе с 
  ним клиента vrcv, то получатся те же результаты, что и раньше.</p>
<p style='text-align:justify;'>В спецификации Winsock определен другой, хотя и 
  похожий интерфейс.</p>
<div style='border:solid windowtext .5pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'> 
  <p style='text-align:justify;border:none;padding:0cm;'>#include &lt;winsock2.h&gt;</p>
  <p style='text-align:justify;border:none;padding:0cm;'>int WSAAPI WSAsend (SOCKET 
    s, LPWSABUF, DWORD cnt, LPDWORD sent, DWORD flags, LPWSAOVERLAPPED ovl, LPWSAOVERLAPPED_COMPLETION_ROUTINE 
    func );</p>
  <p style='text-align:justify;border:none;padding:0cm;'>Возвращаемое значение: 
    0 в случае успеха, в противном случае SOCKET_ERROR.</p>
</div>
<p style='text-align:justify;'>Последние два аргумента используются при вводе/выводе 
  с перекрытием, и в данном случае не имеют значения, так что обоим присваивается 
  значение NULL. параметр buf указывает на массив структур типа WSABUF, играющих 
  ту же роль, Что структуры iovec в вызове writev.</p>
<p style='text-align:justify'>typedef struct _WSABUF {</p>
<p style='text-align:justify;'> u_longlen; /* Длина буфера. */</p>
<p style='text-align:justify'> char FAR * buf; /* Указатель на начало буфера. 
  */</p>
<p style='text-align:justify'>} WSABUF, FAR * LPWSABUF;</p>
<p style='text-align:justify;'>Параметр sent - это указатель на переменную типа 
  DWORD, в которой хранится число переданных байт при успешном завершении вызова. 
  Параметр flags аналогичен одноименному параметру в вызове send.</p>
<p style='text-align:justify;'>Версия клиента, посылающего сообщения переменной 
  длины, на платформе Windows выглядит так (листинг 3.24):</p>
<p style='text-align:justify'>Листинг 3.24. Версия vrcv для Winsock</p>
<p style='text-align:justify'><a href="source\vrcvw.c">vrcvw.с</a></p>
<p style='text-align:justify;'>1    #include &quot;etcp.h&quot;</p>
<p style='text-align:justify;'>2    int main( int argc, char **argv )</p>
<p style='text-align:justify;'>3    {</p>
<p style='text-align:justify;'>4    SOCKET s;</p>
<p style='text-align:justify;'>5    int n;</p>
<p style='text-align:justify;'>6    char buf[ 128 ] ;</p>
<p style='text-align:justify;'>7    WSABUF wbuf[ 2 ];</p>
<p style='text-align:justify;'>8    DWORD sent;</p>
<p style='text-align:justify;'>9    INIT();</p>
<p style='text-align:justify;'>10   s = tcp_client( argv[ 1 ], argv[ 2 ] ) ;</p>
<p style='text-align:justify;'>11   wbuf[ 0 ].buf = ( char * )&amp;n;</p>
<p style='text-align:justify;'>12   wbuf[ 0 ].len = sizeof( n );</p>
<p style='text-align:justify;'>13   wbuf[ 1 ].buf = buf;</p>
<p style='text-align:justify;'>14   while ( fgets( buf, sizeof( buf ), stdin ) 
  != NULL )</p>
<p style='text-align:justify;'>15   {</p>
<p style='text-align:justify;'>16     wbuff 1 ].len = strlen( buf );</p>
<p style='text-align:justify;'>17     n = htonl ( wbuff 1 ].len );</p>
<p style='text-align:justify;'>18     if ( WSASend( s, wbuf, 2, &amp;sent, 0, 
  NULL, NULL ) &lt; 0 )</p>
<p style='text-align:justify;'>19      error( 1, errno, &quot;ошибка вызова WSASend&quot; 
  );</p>
<p style='text-align:justify;'>20   }</p>
<p style='text-align:justify;'>21   EXIT( 0 );</p>
<p style='text-align:justify;'>22   }</p>
<p style='text-align:justify;'>Как видите, если не считать иного обращения к вызову 
  записи со сбором, то Winsock-версия идентична UNIX-версии.</p>
<h3><a name="p3">Резюме</a></h3>
<p style='text-align:justify;'>В этом разделе разобран алгоритм Нейгла и его взаимодействие 
  с алгоритмом отложенного подтверждения. Приложения, записывающие в сеть несколько 
  маленьких блоков вместо одного большого, могут заметно снизить производительность.</p>
<p style='text-align:justify'>Поскольку алгоритм Нейгла помогает предотвратить 
  действительно серьезную проблему - переполнение сети крохотными пакетами, не 
  следует отключать его для повышения производительности приложений, выполняющих 
  запись мелкими блока­ми. Вместо этого следует переписать приложение так, чтобы 
  все логические связан­ные данные выводились сразу. Здесь был рассмотрен удобный 
  способ решения этой задачи с помощью системного вызова writev в UNIX или WSASend 
  в Winsock.</p>
<hr><div align="right"><a href="adv24.htm#top">Вверх</a> | <a href="index.htm">Содержание</a> | <a href="adv23.htm">Назад</a> | <a href="adv25.htm">Далее</a></div>
</body>
</html>
