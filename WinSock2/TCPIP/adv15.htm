<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<link href="style.css" type="text/css" rel=stylesheet>
<title>Глава 3</title>
</head>
<body lang=RU link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">
<h1><a name="top">Глава 3. Создание эффективных и устойчивых сетевых 
  программ</a></h1>
<h2><a name="p1">Совет 15. Разберитесь с операцией записи в </a>TCP</h2>
<hr><div align="right"><a href="adv15.htm#p4">Вниз</a> | <a href="index.htm">Содержание</a> | <a href="adv14.htm">Назад</a> | <a href="adv16.htm">Далее</a></div>
<p style='text-align:justify;'>Здесь и далее обсуждаются некоторые особенности 
  операций чтения и записи при программировании TCP/IP. Представляет интерес не 
  конкретный API и детали системных вызовов, а семантические вопросы, связанные 
  с этими операциями.</p>
<p style='text-align:justify;'>Как сказано в совете 6, между операциями записи 
  и посылаемыми TCP сегментами нет взаимно-однозначного соответствия. Как именно 
  соотносятся обращения к операции записи с протоколом TCP, зависит от системы, 
  но все же спецификации протокола достаточно определенны и можно сделать некоторые 
  выводы при знакомстве с конкретной реализацией. Традиционная реализация подробно 
  описана в системе BSD. Она часто рассматривается как эталонная, и ее исходные 
  тексты доступны.</p>
<p style='text-align:justify;'><i>Примечание:</i> Исходные  тексты  оригинальной 
  реализации  для  системы 4.4BSD-lite2 можно получить на CD-ROM у компании WalnutCreek 
  (http:// www.cdrom.com). Подробные пояснения к исходному тексту вы найдете в 
  книге [Wright and Stevens 1995].</p>
<h3><a name="p2">Операция записи с точки зрения приложения</a></h3>
<p style='text-align:justify;'>Когда пользователь выполняет запись в TCP-соединение, 
  данные сначала копируются из буфера пользователя в память ядра. Дальнейшее зависит 
  от состояния соединения. TCP может «решить», что надо послать все данные, только 
  часть или ничего не посылать. О том, как принимается решение, будет сказано 
  ниже. Сначала рассмотрим операцию записи с точки зрения приложения.</p>
<p style='text-align:justify;'>Хочется думать, что если операция записи n байт 
  вернула значение n, то все эти n байт, действительно, переданы на другой конец 
  и, возможно, уже подтверждены. Увы, это не так. TCP посылает столько данных, 
  сколько возможно (или ничего), и немедленно возвращает значение n. Приложение 
  не определяет, какая часть данных послана и были ли они подтверждены.</p>
<p style='text-align:justify;'>В общем случае операция записи не блокирует процесс, 
  если только буфер передачи TCP не полон. Это означает, что после записи управление 
  почти всегда быстро возвращается программе. После получения управления нельзя 
  ничего гарантировать относительно местонахождения «записанных» данных. Как упоминается 
  в совете 9, это имеет значение для надежности передачи данных.</p>
<p style='text-align:justify;'>С точки зрения приложения данные записаны. Поэтому, 
  помня о гарантиях доставки, предлагаемых TCP, можно считать, что информация 
  дошла до другого конца. В действительности, некоторые (или все) эти данные в 
  момент возврата из операции записи могут все еще стоять в очереди на передачу. 
  И если хост или при­ложение на другом конце постигнет крах, то информация будет 
  потеряна.</p>
<p style='text-align:justify;'><i>Примечание:</i>  Если отправляющее приложение 
  завершает сеанс аварийно, то TCP все равно будет пытаться доставить данные.</p>
<p style='text-align:justify;'>Еще один важный момент, который нужно иметь в виду, 
  - это обработка ошибки записи. Если при записи на диск вызов write не вернул 
  код ошибки, то точно известно, что запись была успешной.</p>
<p style='text-align:justify;'><i>Примечание:</i> Строго говоря, это неверно. 
  Обычно данные находятся в буфере в пространстве ядра до того момента, пока не 
  произойдет сброс буферов на диск. Поэтому если до этого момента система «упадет», 
  то данные вполне могут быть потеряны. Но суть в том, что после возврата из write 
  уже не будет никаких сообщений об ошибках. Можно признать потерю не сброшенных 
  на диск данных неизбежной, но не более вероятной, чем отказ самого диска.</p>
<p style='text-align:justify;'>При работе с TCP получение кода ошибки от операции 
  записи - очень редкое явление. Поскольку операция записи возвращает управление 
  до фактической от правки данных, обычно ошибки выявляются при последующих операциях, 
  о чем говорилось в совете 9. Так как следующей операцией чаще всего бывает чтение, 
  предполагается, что ошибки записи обнаруживаются при чтении. Операция записи 
  возвращает лишь ошибки, очевидные в момент вызова, а именно:</p>
<ul type=disc>
  <li style='text-align:justify;     '>неверный дескриптор сокета;</li>
  <li style='text-align:justify;     '>файловый дескриптор указывает не на сокет 
    (в случае вызова send и родственных функций);</li>
  <li style='text-align:justify;     '>указанный при вызове сокет не существует 
    или не подсоединен;</li>
  <li style='text-align:justify;     '>в качестве адреса буфера указан недопустимый 
    адрес.</li>
</ul>
<p style='text-align:justify;'>Причина большинства этих проблем - ошибка в программе. 
  После заверше­ния стадии разработки они почти не встречаются. Исключение составляет 
  код ошибки EPIPE (или сигнал SIGPIPE), который свидетельствует о сбросе соедине­ния 
  хостом на другом конце. Условия, при которых такая ошибка возникает, обсуждались 
  в совете 9 при рассмотрении краха приложения-партнера.</p>
<p style='text-align:justify;'>Подводя итог этим рассуждениям, можно сказать, 
  что применительно к TCP соединениям операцию записи лучше представлять себе 
  как копирование в очередь для передачи, сопровождаемое извещением TCP о появлении 
  новых данных. Понятно, какую работу TCP произведет дальше, но эти действия будут 
  асинхронны по отношению к самой записи.</p>
<h3><a name="p3">Операция записи с точки зрения </a>TCP</h3>
<p style='text-align:justify;'>Как отмечалось выше, операция записи отвечает лишь 
  за копирование данных из буфера приложения в память ядра и уведомление TCP о 
  том, что появились данные для передачи. А теперь рассмотрим некоторые из критериев, 
  которыми руководствуется TCP, «принимая решение» о том, можно ли передать новые 
  данные незамедлительно и в каком количестве. Я не задаюсь целью полностью объяснить 
  логику отправки данных в TCP, а хочу лишь помочь вам составить пред­ставление 
  о факторах, влияющих на эту логику. Тогда вы сможете лучше понять принципы работы 
  своих программ.</p>
<p style='text-align:justify;'>Одна из основных целей стратегии отправки данных 
  в TCP - максимально эффективное использование имеющейся полосы пропускания. 
  TCP посылает данные блоками, размер которых равен MSS (maximum segment size 
  - максимальный раз­мер сегмента).</p>
<p style='text-align:justify;'><i>Примечание:</i> В процессе установления соединения 
  TCP на каждом конце может указать приемлемый для него MSS. TCP на другом конце 
  обязан удовлетворить это пожелание и не посылать сегменты большего размера. 
  MSS вычисляется на основе MTU (maximum transmission unit - максимальный размер 
  передаваемого блока),как описано в совете 7.</p>
<p style='text-align:justify;'>В то же время TCP не может переполнять буферы на 
  принимающем конце. Как вы видели в совете 1, это определяется окном передачи.</p>
<p style='text-align:justify;'>Если бы эти два условия были единственными, то 
  стратегия отправки была бы проста: немедленно послать все имеющиеся данные, 
  упаковав их в сегменты раз­мером MSS, но не более чем разрешено окном передачи. 
  К сожалению, есть и дру­гие факторы.</p>
<p style='text-align:justify;'>Прежде всего, очень важно не допускать перегрузки 
  сети. Если TCP неожиданно пошлет в сеть большое число сегментов, может исчерпаться 
  память маршрутизатора, что повлечет за собой отбрасывание датаграмм. А из-за 
  этого начнутся повторные передачи, что еще больше загрузит сеть. В худшем случае 
  сеть будет загружена настолько, что датаграммы вообще нельзя будет доставить. 
  Это называ­ется затором (congestion collapse). Чтобы избежать перегрузки, TCP 
  не посылает по простаивающему соединению все сегменты сразу. Сначала он посылает 
  один сегмент и постепенно увеличивает число неподтвержденных сегментов в сети, 
  пока не будет достигнуто равновесие.</p>
<p style='text-align:justify;'><i>Примечание:</i> Эту проблему можно наглядно 
  проиллюстрировать таким примером. Предположим, что в комнате, полной народу, 
  кто-то закричал: «Пожар!» Все одновременно бросаются к дверям, возникает давка, 
  и в результате никто не может выйти. Если же люди будут выходить по одному, 
  то пробки не возникнет, и все благополучно покинут помещение.</p>
<p style='text-align:justify;'>Для предотвращения перегрузки TCP применяет два 
  алгоритма, в которых используется еще одно окно, называемое окном перегрузки. 
  Максимальное число байтов, которое TCP может послать в любой момент, - это минимальная 
  из двух величин: размер окна передачи и размер окна перегрузки. Обратите внимание, 
  что эти окна отвечают за разные аспекты управления потоком. Окно передачи, декларируемое 
  TCP на другом конце, предохраняет от переполнения его буферов. Окно перегруз­ки, 
  отслеживаемое TCP на вашем конце, не дает превысить пропускную способ­ность 
  сети. Ограничив объем передачи минимальным из этих двух окон, вы удов­летворяете 
  обоим требованиям управления потоком.</p>
<p style='text-align:justify;'>Первый алгоритм управления перегрузкой называется 
  «медленный старт». Он постепенно увеличивает частоту передачи сегментов в сеть 
  до пороговой величины.</p>
<p style='text-align:justify;'><i>Примечание:</i> Слово «медленный» взято в кавычки, 
  поскольку на самом деле нарастание частоты экспоненциально. При медленном старте 
  окно перегрузки открывается на один сегмент при получении каждого АСК. Если 
  вы начали с одного сегмента, то последовательные размеры окна будут составлять 
  1,2, 4, 8 и т.д.</p>
<p style='text-align:justify;'>Когда размер окна перегрузки достигает порога, 
  который называется порогом медленного старта, этот алгоритм прекращает работу, 
  и в дело вступает алгоритм избежания перегрузки. Его работа предполагает, что 
  соединение достигло равно­весного состояния, и сеть постоянно зондируется - 
  не увеличилась ли пропускная способность. На этой стадии окно перегрузки открывается 
  линейно — по одному сегменту за период кругового обращения.</p>
<p style='text-align:justify;'>В стратегии отправки TCP окно перегрузки в принципе 
  может запретить посы­лать данные, которые в его отсутствие можно было бы послать. 
  Если происходит перегрузка (о чем свидетельствует потерянный сегмент) или сеть 
  некоторое время простаивает, то окно перегрузки сужается, возможно, даже до 
  размера одного сег­мента. В зависимости от того, сколько данных находится в 
  очереди, и сколько их пытается послать приложение, это может препятствовать 
  отправке всех данных.</p>
<p style='text-align:justify;'>Авторитетным источником информации об алгоритмах 
  избежания перегрузки является работа Jacobson 1988], в которой они впервые были 
  предложены. Джекобсон привел результаты нескольких экспериментов, демонстрирующие 
  замет­ное повышение производительности сети после внедрения управления перегруз­кой. 
  В книге [Stevens-1994] содержится подробное объяснение этих алгоритмов и результаты 
  трассировки в локальной сети. В настоящее время эти алгоритмы сле­дует включать 
  в любую реализацию, согласующуюся со стандартом (RFC 1122 [Braden 1989]).</p>
<p style='text-align:justify;'><i>Примечание:</i> Несмотря на впечатляющие результаты, 
  реализация этих алгоритмов очень проста&nbsp;— всего две переменные состояния 
  и несколько строчек кода. Детали можно найти в книге [Wright and Stevens 1995].</p>
<p style='text-align:justify;'>Еще один фактор, влияющий на стратегию отправки 
  TCP, - алгоритм Нейгла. Этот алгоритм впервые предложен в RFC 896 [Nagle 1984]. 
  Он требует, чтобы ни­когда не было более одного неподтвержденного маленького 
  сегмента, то есть сегмента размером менее MSS. Цель алгоритма Нейгла — не дать 
  TCP забить сеть последовательностью мелких сегментов. Вместо этого TCP сохраняет 
  в своих буферах небольшие блоки данных, пока не получит подтверждение на предыдущий 
  маленький сегмент, после чего посылает сразу все накопившиеся данные. В совете 
  24 вы увидите, что отключение алгоритма Нейгла может заметно сказаться на производительности 
  приложения.</p>
<p style='text-align:justify;'>Если приложение записывает данные небольшими порциями, 
  то эффект от алгоритма Нейгла очевиден. Предположим, что есть простаивающее 
  соединение, окна передачи и перегрузки достаточно велики, а выполняются подряд 
  две небольшие операции записи. Данные, записанные вначале, передаются немедленно, 
  поскольку окна это позволяют, а алгоритм Нейгла не препятствует, так как неподтвержденных 
  данных нет (соединение простаивало). Но, когда до TCP доходят данные, получен­ные 
  при второй операции, они не передаются, хотя в окнах передачи и перегрузки есть 
  место. Поскольку уже есть один неподтвержденный маленький сегмент, и алго­ритм 
  Нейгла требует оставить данные в очереди, пока не придет АСК.</p>
<p style='text-align:justify;'>Обычно при реализации алгоритма Нейгла не посылают 
  маленький сегмент, если есть неподтвержденные данные. Такая процедура рекомендована 
  RFC 1122. Но реализация в BSD (и некоторые другие) несколько отходит от этого 
  правила и отправляет маленький сегмент, если это последний фрагмент большой 
  одновре­менно записанной части данных, а соединение простаивает. Например, MSS 
  для простаивающего соединения равен 1460 байт, а приложение записывает 1600 
  байт. При этом TCP пошлет (при условии, что это разрешено окнами передачи и 
  перегрузки) сначала сегмент размером 1460, а сразу вслед за ним, не дожидаясь 
  под­тверждения, сегмент размером 140. При строгой интерпретации алгоритма Ней­гла 
  следовало бы отложить отправку второго сегмента либо до подтверждения первого, 
  либо до того, как приложение запишет достаточно данных для формиро­вания полного 
  сегмента.</p>
<p style='text-align:justify;'>Алгоритм Нейгла - это лишь один из двух алгоритмов, 
  позволяющих избе­жать синдрома безумного окна (SWS - silly window syndrome). 
  Смысл этой так­тики в том, чтобы не допустить отправки небольших объемов данных. 
  Синдром SWS и его отрицательное влияние на производительность обсуждаются в 
  RFC 813 [Clark 1982]. Как вы видели, алгоритм Нейгла пытается избежать синдрома 
  SWS со стороны отправителя. Но требуются и усилия со стороны получателя, который 
  не должен декларировать слишком маленькие окна.</p>
<p style='text-align:justify;'>Напомним, что окно передачи дает оценку свободного 
  места в буферах хоста на другом конце соединения. Этот хост объявляет о том, 
  сколько в нем имеется места, включая в каждый посылаемый сегмент информацию 
  об обновлении окна. Чтобы избежать SWS, получатель не должен объявлять о небольших 
  изменениях.</p>
<p style='text-align:justify;'>Следует пояснить это на примере. Предположим, у 
  получателя есть 14600 сво­бодных байт, a MSS составляет 1460 байт. Допустим 
  также, что приложением на Конце получателя читается за один раз всего по 100 
  байт. Отправив получателю 10 сегментов, окно передачи закроется. И вы будете 
  вынуждены приостановить отправку данных. Но вот приложение прочитало 100 байт, 
  в буфере приема 100 байт освободилось. Если бы получатель объявил об этих 100 
  байтах, то вы тут же послали бы ему маленький сегмент, поскольку TCP временно 
  отменяет алгоритм Нейгла, если из-за него длительное время невозможно отправить 
  маленький сегмент. Вы и дальше продолжали бы посылать стобайтные пакеты, так 
  как всякий раз, когда приложение на конце получателя читает очередные 100 байт, 
  получатель объявляет освобождении этих 100 байт, посылая информацию об обновлении 
  окна.</p>
<p style='text-align:justify;'>Алгоритм избежания синдрома SWS на получающем конце 
  не позволяет объявлять об обновлении окна, если объем буферной памяти значительно 
  не увеличился. В RFC 1122 «значительно» - это на размер полного сегмента или 
  более чем на половину максимального размера окна. В реализациях, производных 
  от BSD, требуется увеличение на два полных сегмента или на половину максималь­ного 
  размера окна.</p>
<p style='text-align:justify;'>Может показаться, что избежание SWS со стороны 
  получателя излишне (поскольку отправителю не разрешено посылать маленькие сегменты), 
  но в действи­тельности это защита от тех стеков TCP/IP, в которых алгоритм Нейгла 
  не реали­зован или отключен приложением (совет 24). RFC 1122 требует от реализаций 
  TCP, удовлетворяющих стандарту, осуществлять избежание SWS на обоих концах.</p>
<p style='text-align:justify;'>На основе этой информации теперь можно сформулировать 
  стратегию отправ­ки, принятую в реализациях TCP, производных от BSD. В других 
  реализациях стратегия может быть несколько иной, но основные принципы сохраняются.</p>
<p style='text-align:justify;'>При каждом вызове процедуры вывода TCP вычисляет 
  объем данных, кото­рые можно послать. Это минимальное значение количества данных 
  в буфере пере­дачи, размера окон передачи и перегрузки и MSS. Данные отправляются 
  при выполнении хотя бы одного из следующих условий:</p>
<ul type=disc>
  <li style='text-align:justify;     '>можно послать полный сегмент размером MSS;</li>
  <li style='text-align:justify;     '>соединение простаивает, и можно опустошить 
    буфер передачи;</li>
  <li style='text-align:justify;     '>алгоритм Нейгла отключен, и можно опустошить 
    буфер передачи;</li>
  <li style='text-align:justify;     '>есть срочные данные для отправки;</li>
  <li style='text-align:justify;     '>есть маленький сегмент, но его отправка 
    уже задержана на достаточно дли тельное время;</li>
</ul>
<p style='text-align:justify;'><i>Примечание:</i> Если у TCP есть маленький сегмент, 
  который запрещено посылать, то он взводит таймер на то время, которое потребовалось 
  бы для ожидания АСК перед повторной передачей (но в пределах 5-60 с). Иными 
  словами, устанавливается тайм-аут ретрансмиссии (RТО). Если этот таймер, называемый 
  таймером терпения (persist timer), срабатывает, то TCP все-таки посылает сегмент 
  при условии, что это не противоречит ограничениям, которые накладывают окна 
  передачи и перегрузки. Даже если получатель объявляет окно размером нуль байт, 
  TCP все равно попытается послать один байт. Это делается для того, чтобы потерянное 
  обновление окна не привело к тупиковой ситуации.</p>
<ul type=disc>
  <li style='text-align:justify;     '>окно приема, объявленное хостом на другом 
    конце, открыто не менее чем на­половину;</li>
  <li style='text-align:justify;     '>необходимо повторно передать сегмент; </li>
  <li style='text-align:justify;     '>требуется послать АСК на принятые данные;</li>
  <li style='text-align:justify;     '>нужно объявить об обновлении окна.</li>
</ul>
<h3><a name="p4">Резюме</a></h3>
<p style='text-align:justify;'>В этом разделе подробно рассмотрена операция записи. 
  С точки зрения прило­жения операцию записи проще всего представлять как копирование 
  из адресного пространства пользователя в буферы ядра и последующий возврат. 
  Срок передачи данных TCP и их объем зависят от состояния соединения, а приложение 
  не умеет подобной информации.</p>
<p>Проанализированы стратегия отправки, принятая в BSD TCP, а также влия­ние на 
  нее объема буферной памяти у получателя (представлен окном передачи), оценки 
  загрузки сети (представлена окном перегрузки), объема данных, готовых для передачи, 
  попытки избежать синдрома безумного окна и стратегии повторной передачи.</p>
<hr><div align="right"><a href="adv15.htm#top">Вверх</a> | <a href="index.htm">Содержание</a> | <a href="adv14.htm">Назад</a> | <a href="adv16.htm">Далее</a></div>
</body>
</html>
