<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<link href="style.css" type="text/css" rel=stylesheet>
<title>Приложение 1</title>
</head>
<body lang=RU link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">
<h1><a name="top">Приложение 1</a></h1>
<hr><div align="right"><a href="app1.htm#end">Вниз</a> | <a href="index.htm">Содержание</a> | <a href="adv44.htm">Назад</a> | <a href="app2.htm">Далее</a></div>
<h2><a name="p1">Вспомогательный код для </a>UNIX</h2>
<p><i>Заголовочный файл </i>etcp.h</p>
<p>Почти все программы в этой книге начинаются с заголовочного файла etcp. h (листинг 
  П1.1). Он подключает и другие необходимые файлы, в том числе skel. h  (листинг 
  П2.1), а также определения некоторых констант, типов данных и прото-типов.</p>
<p>        Листинг П1.1. Заголовочный файл etcp, h</p>
<p><a href="source\etcp.h">еtcp.h</a></p>
<p>1          #ifndef _ETCP_H_</p>
<p>2          #define _ЕТСР_Н_</p>
<p>3          /* Включаем стандартные заголовки. */</p>
<p>4          #include &lt;errno.h&gt;</p>
<p>5          #include &lt;stdlib.h&gt;</p>
<p>6          #include &lt;unistd.h&gt;</p>
<p>7          #include &lt;stdio.h&gt;</p>
<p>8          #include &lt;stdarg.h&gt;</p>
<p>9          #include &lt;string.h&gt;</p>
<p>10        #include &lt;netdb.h&gt;</p>
<p>11        #include &lt;signal.h&gt;</p>
<p>12        #include &lt;fcntl.h&gt;</p>
<p>13        #include &lt;sys/socket.h&gt;</p>
<p>14        #include &lt;sys/wait.h&gt;</p>
<p>15        #include &lt;sys/time.h&gt;</p>
<p>16        #include &lt;sys/resource.h&gt;</p>
<p>17        #include &lt;sys/stat.h&gt;</p>
<p>18        #include &lt;netinet/in.h&gt;</p>
<p>19        #include &lt;arpa/inet.h&gt;</p>
<p>20        #include &quot;skel.h&quot;</p>
<p>21        #define TRUE   1</p>
<p>22        #define FALSE  0</p>
<p>23        #define NLISTEN 5  /* Максимальное число ожидающих соединений. */</p>
<p>24        #define NSMB   5  /* Число буферов в разделяемой памяти. */</p>
<p>25        #tdefine SMBUFSZ256/* Размер буфера в разделяемой памяти. */</p>
<p>26        extern char *program_name;     /* Для сообщений об ошибках. */</p>
<p>27        #ifdef _SVR4</p>
<p>28        #define bzero(b,n) memset( ( b ), 0, ( n ) )</p>
<p>29        #endif</p>
<p>30        typedef void ( *tofunc_t ) ( void * ) ;</p>
<p>31        void error( int, int, char*, ... );</p>
<p>32        int readn( SOCKET, char *, size_t );</p>
<p>33        int readvrect SOCKET, char *, size_t ) ;</p>
<p>34        int readcrlf( SOCKET, char *, size_t ) ;</p>
<p>35        int readline( SOCKET, char *, size_t ) ;</p>
<p>36        int tcp_server( char *, char * };</p>
<p>37        int tcp_client ( char *, char * ) ;</p>
<p>38        int udp_server ( char *, char * } ;</p>
<p>39        int udp_client( char *, char *, struct sockaddr_in * );</p>
<p>40        int tselect( int, fd_set *, fd_set *, fd_set *);</p>
<p>41        unsigned int timeout( tofunc_t, void *, int );</p>
<p>42        void untimeout( unsigned int );</p>
<p>43        void init_smb( int ) ;</p>
<p>44        void *smballoc( void ) ;</p>
<p>45        void smbfree( void * ) ;</p>
<p>46        void smbsendf SOCKET, void * );</p>
<p>47        void *smbrecv( SOCKET ) ;</p>
<p>48        void set_address ( char *, char *, struct sockaddr_in *', char *           
  ) ;</p>
<p>49        #endif  /* _ETCP_H_ */</p>
<p><b><i>Функция </i></b><b><i>daemon</i></b></p>
<p style='text-align:justify;'>Функция daemon, которая использована в программе 
  tcpmux, входит в стандартную библиотеку, поставляемую с системой BSD. Для систем 
  SVR4 приводится версия, текст которой показан в листинге П1.2.</p>
<p>Листинг П1.2. Функция daemon</p>
<p>daemon.с</p>
<p>1       int daemon( int nocd, int noclose )</p>
<p><sup>2          (</sup></p>
<p>3       struct rlimit rlim;</p>
<p>4       pid_t pid;</p>
<p>5       int i;</p>
<p>6       mask( 0 );    /* Очистить маску создания файлов. */</p>
<p>7       /* Получить максимальное число открытых файлов. */</p>
<p>8       if ( getrlimit( RLIMIT_NOFILE, &amp;rlim ) &lt; 0 )</p>
<p>9                error( 1, errno, &quot;getrlimit failed&quot; );</p>
<p>10     /* Стать лидером сессии, потеряв при этом управляющий терминал... */</p>
<p>11     pid = fork();</p>
<p>12     if ( pid &lt; 0 )</p>
<p>13              return -1;</p>
<p>14     if ( pid != 0 )</p>
<p>15              exit( 0 ) ;</p>
<p>16     setsid();</p>
<p>17     /* ... и гарантировать, что больше его не будет. */</p>
<p>18     signal( SIGHUP, SIG_IGN );</p>
<p>19     pid = fork(};</p>
<p>20     if ( pid &lt; 0 )</p>
<p>21              return -1;</p>
<p>22     if ( pid != 0 )</p>
<p>23              exit( 0 );</p>
<p>24     * Сделать текущим корневой каталог, ее ли не требовалось обратное */</p>
<p>25     if ( !nocd )</p>
<p>26              chdir( &quot;/&quot; ) ;</p>
<p>27     /*</p>
<p>28     * Если нас не просили этого не делать, закрыть все файлы.</p>
<p>29     * Затем перенаправить stdin, stdout и stderr</p>
<p>30     * на /dev/null.</p>
<p>31     */</p>
<p>32     if (!noclose }</p>
<p>33     {</p>
<p>34     #if 0 /* Заменить на 1 для закрытия всех файлов. */</p>
<p>35     if ( rlim.rlim_max == RLIM_INFINITY )</p>
<p>3                rlim.rlim_max = 1024;</p>
<p>37     for ( i = 0; i &lt; rlim.rlim_max; i++ )</p>
<p>38              close( i );</p>
<p>39     endif</p>
<p>40     i = open( &quot;/dev/null&quot;, 0_RDWR );</p>
<p>41     f ( i &lt; 0 )</p>
<p>42              return -1;</p>
<p>43     up2( i, 0 ) ;</p>
<p>44     up2( i, 1 };</p>
<p>45     up2( i, 2 );</p>
<p>46     f ( i &gt; 2 )</p>
<p>47              close( i ) ;</p>
<p>48     }</p>
<p>49     return 0;</p>
<p>50     }</p>
<p><b><i>Функция </i></b><b><i>signal</i></b></p>
<p style='text-align:justify'> В этой книге уже упоминалось, что в некоторых версиях 
  UNIX функция s ignal реализована на основе семантики ненадежных сигналов. В 
  таком случае для полу­чения семантики надежных сигналов следует использовать 
  функцию sigaction. Чтобы повысить переносимость, необходимо реализовать signal 
  с помощью sigaction (листинг П1.3)</p>
<p>Листинг П 1.3. Функция signal</p>
<p>signal. c</p>
<p><i>/*   </i>signal   -  надежная  версия для  SVR4  и некоторых других        
  систем.   <i>*/</i></p>
<p>1       typedef void sighndlr_t(   int   );</p>
<p>2       sighndlr_t   *signal(   int   sig,   sighndlr_t   *hndlr   )</p>
<p>3       {</p>
<p>4                struct sigaction act;</p>
<p>5                struct sigaction xact;</p>
<p>6                act.sa_handler = hndlr;</p>
<p>7                act.sa_flags =0;</p>
<p>8                sigemptyset( &amp;act.sa_mask );</p>
<p>9                if ( sigaction( sig, &amp;act, &amp;xact ) &lt; 0 )</p>
<p>10                    return SIG_ERR;</p>
<p>11              return xact.sa_handler;</p>
<p>12     }</p>
<a name="end"></a><hr><div align="right"><a href="app1.htm#top">Вверх</a> | <a href="index.htm">Содержание</a> | <a href="adv44.htm">Назад</a> | <a href="app2.htm">Далее</a></div>
</body>
</html>
