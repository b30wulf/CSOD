<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<link href="style.css" type="text/css" rel=stylesheet>
<title>Совет 22</title>
</head>
<body lang=RU link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">
<h2><a name="top">Совет 22. Не прерывайте состояние </a>TIME-WAIT для закрытия 
  соединения</h2>
<hr><div align="right"><a href="adv22.htm#p4">Вниз</a> | <a href="index.htm">Содержание</a> | <a href="adv21.htm">Назад</a> | <a href="adv23.htm">Далее</a></div>
<p style='text-align:justify;'>В этом разделе рассказывается о том, что такое 
  состояние TIME-WAIT в протоколе TCP, для чего оно служит и почему не следует 
  пытаться обойти его.</p>
<p style='text-align:justify;'>Поскольку состояние TIME-WAIT запрятано глубоко 
  в недрах конечного автомата, управляющего работой TCP, многие программисты только 
  подозреваю о его существовании и смутно представляют себе назначение и важность 
  этого с стояния. Писать приложения TCP/IP можно, ничего не зная о состоянии 
  ТIME-WAIT, но необходимо разобраться в странном, на первый взгляд, поведении 
  приложения (совет 23). Это позволит избежать непредвиденных последствий.</p>
<p style='text-align:justify;'>Рассмотрим состояние TIME-WAIT и определим, каково 
  его место в работе TCP-соединения. Затем будет рассказано о назначении этого 
  состояния и его важности, а также, почему и каким образом некоторые программисты 
  пытаются обойти это состояние. В конце дано правильное решение этой задачи.</p>
<h3><a name="p1">Что это такое</a></h3>
<p style='text-align:justify;'>Состояние TIME-WAIT наступает в ходе разрыва соединения. 
  Помните (совет 7), что для разрыва TCP-соединения нужно обычно обменяться четырьмя 
  сегментами, как показано на рис. 3.8.</p>
<p style='text-align:justify;'>На рис. 3.8 показано соединение между двумя приложениями, 
  работающими на хостах 1 и 2. Приложение на хосте 1 закрывает свою сторону соединения, 
  при этом TCP посылает сегмент FIN хосту 2. Хост 2 подтверждает FIN сегментом 
  АСК и доставляет FIN приложению в виде признака конца файла EOF (предполагается, 
  что у приложения есть незавершенная операция чтения, - совет 16). Позже приложение 
  на хосте 2 закрывает свою сторону соединения, посылая FIN хосту 1, который отвечает 
  сегментом АСК.</p>
<p align=center style='text-align:center;
'> <img width=409 height=365
src="./img/image035.gif" v:shapes="_x0000_i1025"> </p>
<p align=center style='text-align:center;
'>Рис. 3.8. Разрыв соединения</p>
<p style='text-align:justify;'>В этот момент хост 2 окончательно закрывает соединение 
  и освобождает ресурсы. С точки зрения хоста 2, соединения больше не существует. 
  Однако хост 1 закрывает соединение, а переходит в состояние TIME-WAIT и остается 
  в нем в течение двух максимальных продолжительностей существования сегмента 
  (2MSL maximum segment lifetime).</p>
<p style='text-align:justify;'><i>Примечание:</i> Максимальное время существования 
  сегмента (MSL) - это максимальное время, в течение которого сегмент может оставаться 
  в сети, прежде чем будет уничтожен. В каждой IР-датаграммеесть поле TTL (time-to-live 
  - время жизни). Это поле уменьшается нa единицу каждым маршрутизатором, через 
  который проходит датаграмма. Когда TTL становится равным нулю, датаграмма уничтожается. 
  Хотя официально TTL измеряется в секундах, в действительности это поле почти 
  всегда интерпретируется маршрутизаторами как счетчик промежуточных узлов. В 
  RFC 1812 [Baker 1995] этот вопрос обсуждается подробнее.</p>
<p style='text-align:justify;'>Прождав время 2MSL, хост 1 также закрывает соединение 
  и освобождает ресурсы.</p>
<p style='text-align:justify;'>Относительно состояния TIME-WAIT следует помнить 
  следующее:</p>
<ul type=disc>
  <li style='text-align:justify;     '>обычно в состояние TIME-WAIT переходит 
    только одна сторона - та, что выполняет активное закрытие;</li>
</ul>
<p style='text-align:justify;'><i>Примечание:</i> Под активным закрытием понимается 
  отправка первого FIN. Считается, что вторая сторона при этом выполняет пассивное 
  закрытие. Возможно также одновременное закрытие, когда обе стороны закрывают 
  соединение примерно в одно время, поэтому посланные ими FIN одновременно находятся 
  в сети. В этом случае активное закрытие выполняют обе стороны, так что обе переходят 
  в состояние TIME- WAIT.</p>
<ul type=disc>
  <li style='text-align:justify;     '>в RFC 793 [Postel 1981b] MSL определено 
    равным 2 мин. При этом соединение должно оставаться в состоянии TIME-WAIT 
    в течение 4 мин. На прак­тике это обычно не так. Например, в системах, производных 
    от BSD, MSL равно 30 с, так что состояние TIME-WAIT длится всего 1 мин. Можно 
    встретить и другие значения в диапазоне от 30 с до 2 мин;</li>
  <li style='text-align:justify;     '>если в то время, когда соединение находится 
    в состоянии TIME-WAIT, прибывает новый сегмент, то таймер на 2MSL перезапускается. 
    Это будет рассматриваться ниже.</li>
</ul>
<h3><a name="p2">Зачем нужно состояние </a>TIME- WAIT</h3>
<p style='text-align:justify;'>Состояние TIME-WAIT служит двум целям:</p>
<ul type=disc>
  <li style='text-align:justify;     '>не дать соединению пропасть при потере 
    последнего АСК, посланного активной стороной, в результате чего другая сторона 
    повторно посылает FIN;</li>
  <li style='text-align:justify;     '>дать время исчезнуть «заблудившимся сегментам», 
    принадлежащим этому соединению.</li>
</ul>
<p style='text-align:justify;'>Рассмотрим каждую из этих причин. В момент, когда 
  сторона, выполняющая активное закрытие, готова подтвердить посланный другой 
  стороной FIN, все данные, отправленные другой стороной, уже получены. Однако 
  последний АСК может потеряться. Если это произойдет, то сторона, выполняющая 
  пассивное закрытие, обнаружит тайм-аут и пошлет свой FIN повторно (так как не 
  получила АСК на последний порядковый номер).</p>
<p style='text-align:justify;'>А теперь посмотрим, что случится, если активная 
  сторона не перейдет в состояние TIME-WAIT, а просто закроет соединение. Когда 
  прибывает повторно переданный FIN, у TCP уже нет информации о соединении, поэтому 
  он посылает в ответ RST (сброс), что для другой стороны служит признаком ошибки, 
  а не нормального закрытия соединения. Но, так как сторона, пославшая последний 
  АСК, все-таки перешла в состояние TIME-WAIT, информация о соединении еще хранится, 
  так что она может корректно ответить на повторно отправленный FIN.</p>
<p style='text-align:justify;'>Этим объясняется и то, почему 2МSL-таймер перезапускается, 
  если в состоянии TIME-WAIT приходит новый сегмент. Если последний АСК потерян, 
  и другая сторона повторно послала FIN, то сторона, находящаяся в состоянии TIME-WAIT, 
  еще раз подтвердит его и перезапустит таймер на случай, если и этот АСК будет 
  потерян.</p>
<p style='text-align:justify;'>Второе назначение состояния TIME-WAIT более важно. 
  Поскольку IР-дата-граммы могут теряться или задерживаться в глобальной сети, 
  TCP использует механизм подтверждений для своевременной повторной передачи неподтвержден­ных 
  сегментов (совет 1). Если датаграмма просто задержалась в пути, но не потеряна, 
  или потерян подтверждающий ее сегмент АСК, то после прибытия исходных данных 
  могут поступить также и повторно переданные. TCP в этом случае определяет, что 
  порядковые номера поступивших данных находятся вне текущего окна приема, и отбрасывает 
  их.</p>
<p style='text-align:justify;'>А что случится, если задержавшийся или повторно 
  переданный сегмент придет после закрытия соединения? Обычно это не проблема, 
  так как TCP просто отбросит данные и пошлет RST. Когда RST дойдет до хоста, 
  отправившего задержавшийся сегмент, то также будет отброшен, поскольку у этого 
  хоста больше нет информации о соединении. Однако если между этими двумя хостами 
  установлено новое соединение с такими же номерами портов, что и раньше, то заблудившийся 
  сегмент может быть принят как принадлежащий новому соединению. Если порядковые 
  номера данных в заблудившемся сегменте попадают в текущее окно приема нового 
  соединения, то данные будут приняты, следовательно, новое соединение - скомпрометировано.</p>
<p style='text-align:justify;'>Состояние TIME-WAIT предотвращает такую ситуацию, 
  гарантируя, что два прежних сокета (два IP-адреса и соответствующие им номера 
  портов) повторно не используются, пока все сегменты, оставшиеся от старого соединения, 
  не будут уничтожены. Таким образом, вы видите, что состояние TIME-WAIT играет 
  важную роль в обеспечении надежности протокола TCP. Без него TCP не мог бы гарантировать 
  доставку данных по порядку и без искажений (совет 9).</p>
<h3><a name="p3">Принудительная отмена состояния </a>TIME-WAIT</h3>
<p style='text-align:justify;'>К сожалению, иногда можно досрочно выйти из состояния 
  TIM Е-WAIT. Это называется принудительной отменой (TIME-WAIT assassination) 
  и бывает случай но или намеренно.</p>
<p style='text-align:justify;'>Сначала посмотрим, как это может произойти случайно. 
  По стандарта RFC 793, если соединение находится в состоянии TIME-WAIT и приходит 
  RST то соединение должно быть немедленно закрыто. Предположим, что имеет единение 
  в состоянии TIME-WAIT и приходит старый сегмент-дубликат, который TCP не принимает 
  (например, потому, что порядковый номер оказался вне окна приема). TCP посылает 
  в ответ АСК, в котором указано, какой порядковый номер он ожидает (следующий 
  за номером сегмента FIN, посланного другой стороной). Но у хоста на другой стороне 
  уже нет информации о соединении, поэтому этот АСК он отвечает сегментом RST. 
  Когда этот RST приходит хосту, у которого соединение находится в состоянии TIME-WAIT, 
  тот немедленно закрывает соединение, - состояние TIME-WAIT принудительно отменено.</p>
<p style='text-align:justify;'>Эта ситуация описана в RFC 1337 [Braden 1992b], 
  где также рассматриваются трудности, сопряженные с принудительной отменой состояния 
  TIME-WAIT. Опасность состоит в возможности «воскрешения» старого соединения 
  (то есть появления соединения с теми же двумя сокетами), что может привести 
  к подтверждению старых данных, десинхронизации соединения с входом в бесконечный 
  цикл и к ошибочному завершению нового соединения.</p>
<p style='text-align:justify;'>Это легко предотвратить, изменив протокол TCP так, 
  чтобы в состоянии TIME-WAIT было разрешено игнорировать RST Хотя такое изменение, 
  рекомендованное в RFC 1337, официально не одобрено, тем не менее в некоторых 
  стеках оно реализовано.</p>
<p style='text-align:justify;'>Принудительно отменить состояние TIME-WAIT можно 
  и намеренно. С помощью опции сокета SO_LINGER программист требует немедленного 
  закрытия соединения даже в том случае, когда приложение выполняет «активное 
  закрытие. Этот сомнительный прием иногда рекомендуют применять, чтобы вывести 
  «упавший» сервер из состояния TIME-WAIT и запустить его заново. Подробнее об 
  этой проблеме и более правильном способе ее решения будет рассказано в совете 
  23. Корректно написанное приложение никогда не должно манипулировать состоянием 
  TIME-WAIT, поскольку это неотъемлемая часть механизма обеспечения надежности 
  TCP.</p>
<p style='text-align:justify;'>Обычно, когда приложение закрывает соединение, 
  вызов close или closesocket возвращается немедленно, даже если в буфере передачи 
  еще есть данные. Разумеется, TCP будет пытаться доставить эти данные, но приложение 
  не имеет информации, удалось ли это. Чтобы решить эту проблему, можно установить 
  опцию сокета SO_LINGER. Для этого следует заполнить структуру linger и вызывать 
  setsockopt с параметром SO_LINGER.</p>
<p style='text-align:justify;'>В большинстве UNIX-систем структура linger определена 
  в заголовочном файле /usr/include/sys/socket.h. В системе Windows она находится 
  в файле winsock2.h. В любом случае она выглядит так:</p>
<p style='text-align:justify'>struct linger {</p>
<p style='text-align:justify;'>int l_onoff; /*Включить/выключить опцию.*/</p>
<p style='text-align:justify;'>int l_linger; /*Время  задержки.*/</p>
<p style='text-align:justify;'>};</p>
<p style='text-align:justify;'>Если поле l_onoff равно нулю, то опция задержки 
  отключается, и выбирает поведение по умолчанию - вызов close или closesocket 
  возвращается немедленно, а ядро продолжает попытки доставить еще не переданные 
  данные. Если же l_onoff не равно нулю, то работа зависит от значения поля l_linger. 
  Если l_linger отлично от нуля, то считается, что это время, в течение которого 
  ядро должно подождать отправки и подтверждения оставшихся в буфере передает, 
  данных. При этом close или closesocket не возвращается, пока данные не будут 
  доставлены или не истечет указанное время.</p>
<p style='text-align:justify;'>Если к моменту завершения ожидания данные еще не 
  доставлены, то close или closesocket возвращает код EWOULDBLOCK, и недоставленные 
  данные могут быть потеряны. Если все данные уже доставлены, то оба вызова возвращают 
  нуль.</p>
<p style='text-align:justify;'><i>Примечание: </i>К сожалению, семантика поля 
  l_linger зависит от реализации. В Windows и некоторых реализациях UNIX это число 
  секунд, на которое следует задержать закрытие сокета. В системах, производных 
  от BSD, это число тактов таймера (хотя в документации сказано, что это число 
  секунд).</p>
<p style='text-align:justify;'>Используя опцию SO_LINGER таким способом, вы гарантируете, 
  что данные будут доставлены уровню TCP на удаленном хосте. Но они не обязательно 
  будут прочитаны приложением. Более правильный способ добиться последнего - использовать 
  процедуру аккуратного размыкания, описанную в совете 16.</p>
<p style='text-align:justify;'>Если поле l_linger равно нулю, то соединение разрывается. 
  Это означает, что хосту на другом конце посылается RST, и соединение закрывается 
  немедленно, не переходя в состояние TIME-WAIT. Это преднамеренная принудительная 
  отмена состояния TIME-WAIT, о которой упоминалось выше. Как было сказано, это 
  опасный прием, который в обычном приложении применять не следует.</p>
<h3><a name="p4">Резюме</a></h3>
<p style='text-align:justify;'>В этом разделе обсуждено состояние TIME-WAIT, которое 
  часто понимают неправильно. Это состояние - важная часть механизма обеспечения 
  надежности протокола TCP, и попытки обойти его неверны. Преждевременный выход 
  из состояния TIME-WAIT может быть обусловлен «естественным» стечением обстоятельств 
  в сети или программой, которая манипулирует опцией SO_LINGER.</p>
<hr><div align="right"><a href="adv22.htm#top">Вверх</a> | <a href="index.htm">Содержание</a> | <a href="adv21.htm">Назад</a> | <a href="adv23.htm">Далее</a></div>
</body>
</html>
