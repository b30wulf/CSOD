<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<link href="style.css" type="text/css" rel=stylesheet>
<title>Совет 2</title>
</head>
<body lang=RU link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">
<h2><a name="top">Совет 2. Выясните, что такое подсети и </a>CIDR</h2>
<hr><div align="right"><a href="adv2.htm#p9">Вниз</a> | <a href="index.htm">Содержание</a> | <a href="adv1.htm">Назад</a> | <a href="adv3.htm">Далее</a></div>
<p style='text-align:justify;'>Длина IP&nbsp;-адреса (в версии IPv4) составляет 
  32 бита. Адреса принято записывать в десятичной нотации - каждый из четырех 
  байт представляется одним десятичным числом, которые отделяются друг от друга 
  точками. Так, адрес 0x11345678 записывается в виде 17.52.86.120. При записи 
  адресов нужно учитывать, что в некоторых реализациях TCP/IP принято стандартное 
  для языка C соглашение о том, что числа, начинающиеся с нуля, записываются в 
  восьмеричной системе. В таком        случае 17.52.86.120 - это не то же самое, 
  что 017.52.86.120. В первом примере адреcе сети равен 17, а во втором - 15.</p>
<h3><a name="p1">Классы адресов</a></h3>
<p style='text-align:justify;'>По традиции все IP-адреса подразделены на пять 
  классов, показанных на рис. 2.4. Адреса класса D используются для группового 
  вещания, а класс Е зарезервирован для будущих расширений. Остальные классы - 
  А, В и С – предназначены для адресации отдельных сетей и хостов.</p>
<p align=center style='text-align:center;'> <img width=488 height=305
src="./img/image007.gif" v:shapes="_x0000_i1025"> </p>
<p align=center style='text-align:center;'>Рис. 2.4. Классы IP&nbsp;- адресов</p>
<p style='text-align:justify;'>Класс адреса определяется числом начальных единичных 
  битов. У адресов класса А вообще нет бита 1 в начале, у адресов класса В - один 
  такой бит, у адресов класса С - два и т.д. Идентификация класса адреса чрезвычайно 
  важна, поскольку от этого зависит интерпретация остальных битов адреса.</p>
<p style='text-align:justify;'>Остальные биты любого адреса классов А, В и С разделены 
  на две группы. Первая часть любого адреса представляет собой идентификатор сети, 
  вторая -идентификатор хоста внутри этой сети.</p>
<p style='text-align:justify;'><i>Примечание:</i> Биты идентификации класса также 
  считаются частью идентификатора сети. Так, 130.50.10.200 - это адрес класса 
  В, в котором идентификатор сети равен 0x8232.</p>
<p style='text-align:justify;'>Смысл разбивки адресного пространства на классы 
  в том, чтобы обеспечить необходимую гибкость, не теряя адресов. Например, класс 
  А позволяет адресовать сети с огромным (16777214) количеством хостов.</p>
<p style='text-align:justify;'><i>Примечание:</i> Существует 224, или 16777216 
  возможных идентификаторов хостов, но адрес 0 и адрес, состоящий из одних единиц, 
  имеют специальный смысл. Адрес из одних единиц - это широковещательный адрес. 
  IP-датаграммы, посланные по этому адресу, доставляются всем хостам в сети. Адрес 
  0 означает «этот хост»и используется хостом как адрес источника, которому в 
  ходе процедуры начальной загрузки необходимо определить свой истиннный сетевой 
  адрес. Поэтому число хостов в сети всегда равно 2^n&nbsp;- 2, где n&nbsp;- число 
  бит в части адреса, относящейся к хосту.</p>
<p class=MsoBodyTextIndent2>Поскольку в адресах класса А под идентификатор сети 
  отводятся 7 бит, то все­го существует 128 сетей класса А.</p>
<p style='text-align:justify;'><i>Примечание:</i> Как и в случае идентификаторов 
  хостов, два из этих адресов зарезервированы. Адрес 0 означает «эта сеть» и, 
  аналогично хосту 0, используется для определения адреса сети в ходе начальной 
  Р загрузки. Адрес 127 - это адрес «собственной» сети хоста. Датаграммы, адресованные 
  сети 127, не должны покидать хост отправитель. Часто этот адрес называют «возвратным» 
  (loopback) адресом, поскольку отправленные по нему датаграммы «возвращаются» 
  на тот же самый хост.</p>
<p style='text-align:justify;'>На другом полюсе располагаются сети класса С. Их 
  очень много, но в каждой может быть не более 254 хостов. Таким образом, адреса 
  класса А предназначены для немногих гигантских сетей с миллионами хостов, тогда 
  как адреса класса С&nbsp;- для миллионов сетей с небольшим количеством хостов.</p>
<p style='text-align:justify;'>В табл. 2.1 показано, сколько сетей и хостов может 
  существовать в каждом классе, а также диапазоны допустимых адресов. Будем считать, 
  что сеть 127 принадлежит классу А, хотя на самом деле она, конечно, недоступна 
  для адресации.</p>
<p style='text-align:justify'>Таблица 2.1. Число сетей, хостов и диапазоны адресов 
  для классов А, В и С</p>
<table border=1 cellspacing=0 cellpadding=0>
  <tr> 
    <td width=103 valign=top class="Normal"> 
      <p style='text-align:justify;'>Класс</p>
    </td>
    <td width=132 valign=top class="Normal"> 
      <p style='text-align:justify;'>Сети</p>
    </td>
    <td width=120 valign=top class="Normal"> 
      <p style='text-align:justify;'>Хосты</p>
    </td>
    <td width=283 valign=top class="Normal"> 
      <p style='text-align:justify;'>Диапазон адресов</p>
    </td>
  </tr>
  <tr> 
    <td width=103 valign=top class="Normal"> 
      <p style='text-align:justify;'>A</p>
    </td>
    <td width=132 valign=top class="Normal"> 
      <p style='text-align:justify;'>127</p>
    </td>
    <td width=120 valign=top class="Normal"> 
      <p style='text-align:justify;'>16777214</p>
    </td>
    <td width=283 valign=top class="Normal"> 
      <p style='text-align:justify;'>0.0.0.1-127.255.255.255</p>
    </td>
  </tr>
  <tr> 
    <td width=103 valign=top class="Normal"> 
      <p style='text-align:justify;'>B</p>
    </td>
    <td width=132 valign=top class="Normal"> 
      <p style='text-align:justify;'>16384</p>
    </td>
    <td width=120 valign=top class="Normal"> 
      <p style='text-align:justify;'>65534</p>
    </td>
    <td width=283 valign=top class="Normal"> 
      <p style='text-align:justify;'>128.0.0.0-191.255.255.255</p>
    </td>
  </tr>
  <tr> 
    <td width=103 valign=top class="Normal"> 
      <p style='text-align:justify;'>C</p>
    </td>
    <td width=132 valign=top class="Normal"> 
      <p style='text-align:justify;'>2097252</p>
    </td>
    <td width=120 valign=top class="Normal"> 
      <p style='text-align:justify;'>254</p>
    </td>
    <td width=283 valign=top class="Normal"> 
      <p style='text-align:justify;'>192.0.0.0-223.255.255.255</p>
    </td>
  </tr>
</table>
<p style='text-align:justify;'>Первоначально проектировщики набора протоколов 
  TCP/IP полагали, что сети будут исчисляться сотнями, а хосты&nbsp;- тысячами.</p>
<p style='text-align:justify;'><i>Примечание:</i> В действительности, как отмечается 
  в работе [Huitema 1995], в исходном проекте фигурировали только адреса, которые 
  теперь относятся к классу А. Подразделение на три класса былосделано позже, 
  чтобы иметь более 256 сетей</p>
<p style='text-align:justify;'>Появление дешевых, повсеместно применяемых персональных 
  компьютеров привело к значительному росту числа сетей и хостов. Нынешний размер 
  Internet намного превосходит ожидания его проектировщиков.</p>
<p class=MsoBodyTextIndent2>Такой рост выявил некоторые недостатки классов адресов. 
  Прежде всего, число хостов в классах А и В слишком велико. Вспомним, что идентификатор 
  сети, как предполагалось, относится к физической сети, например локальной. Но 
  никто не станет строить физическую сеть из 65000 хостов, не говоря уже о 16000000. 
  Вместо этого большие сети разбиваются на сегменты, взаимосвязанные маршрутизаторами.</p>
<p style='text-align:justify;'>В качестве простого примера рассмотрим два сегмента 
  сети, изображенной<br>
  на рис. 2.5.</p>
<p align=center style='text-align:center;'> <img width=460 height=221
src="./img/image008.gif" v:shapes="_x0000_i1030"> </p>
<p align=center style='text-align:center;'>Рис. 2.5. Сеть из двух сегментов</p>
<p style='text-align:justify;'>Если хосту H1 нужно обратиться к хосту Н2, то он 
  получает физический адрес, соответствующий IP-адресу Н2 (используя для этого 
  метод, свойственный данной реализации физической сети), и помещает датаграмму 
  «на провод».</p>
<p style='text-align:justify;'>А если хосту H1 необходимо обратиться к хосту Н3? 
  Напрямую послать датаграмму невозможно, даже если известен физический адрес 
  получателя, поскольку H1 и Н3 находятся в разных сетях. Поэтому H1 должен отправить 
  датаграмму через маршрутизатор R1. Если у двух сегментов разные идентификаторы 
  сетей, то H1 по своей маршрутной таблице определяет, что пакеты, адресованные 
  сегменту 2, обрабатываются маршрутизатором R1, и отправляет ему датаграмму в 
  предположении, что тот переправит ее хосту Н3.</p>
<p style='text-align:justify;'>Итак, можно назначить двум сегментам различные 
  идентификаторы сети. Но есть и другие решения в рамках системы адресных классов. 
  Во-первых, маршрутная таблица хоста H1 может содержать по одному элементу для 
  каждого хоста в сегменте 2, который определит следующего получателя на пути 
  к этому хосту&nbsp;- R1. Такая же таблица должна размещаться на каждом хосте 
  в сегменте 1. Аналогичные таблицы, описывающие достижимость хостов из сегмента 
  1, следует поместить на каждом хосте из сегмента 2. Очевидно, такое решение 
  плохо масштабируется при значительном количестве хостов. Кроме того, маршрутные 
  таблицы придется вести вручную, что очень скоро станет непосильной задачей для 
  администратора. Поэтому на практике такое решение почти никогда не применяется</p>
<p style='text-align:justify;'>Во-вторых, можно реализовать ARP-прокси (proxy 
  ARP) таким образом, что&nbsp;- бы R1 казался для хостов из сегмента 1 одновременно 
  Н3, Н4 и Н5, а для хостов из сегмента 2&nbsp;– H1, H2 и R2.</p>
<p style='text-align:justify;'><i>Примечание:</i> Агента ARP в англоязычной литературе 
  еще называют promiscuous ARP (пропускающий ARP) или ARP hack (трюк ARP).</p>
<p style='text-align:justify;'>Это решение годится только в случае, когда в физической 
  сети используется протокол ARP (Address Resolution Protocol - протокол разрешения 
  адресов) для отображения IP-адресов на физические адреса. В соответствии с ARP 
  хост, которому нужно получить физический адрес, согласующийся с некоторым IP-адресом, 
  должен послать широковещательное сообщение с просьбой хосту, обладающему данным 
  IP-адресом, выслать свой физический адрес. ARP-запрос получают все хосты в сети, 
  но отвечает только тот, IP-адрес которого совпадает с запрошенным.</p>
<p style='text-align:justify;'>Если применяется агент ARP, то в случае, когда 
  хосту H1 необходимо послать IP-датаграмму НЗ, физический адрес которого неизвестен, 
  он посылает ARP-запрос физического адреса Н3. Но Н3 этот запрос не получит, 
  поскольку нахо­дится в другой сети. Поэтому на запрос отвечает его агент - R1, 
  сообщая свой собственный адрес. Когда R1 получает датаграмму, адресованную Н3, 
  он переправляет ее конечному адресату. Все происходит так, будто Н3 и H1 находятся 
  в одной сети.</p>
<p style='text-align:justify;'>Как уже отмечалось, агент ARP может работать только 
  в сетях, которые используют протокол ARP и к тому же имеют сравнительно простую 
  топологию. Подумайте, что случится при наличии нескольких маршрутизаторов, соединяющих 
  сегменты 1 и 2.</p>
<p style='text-align:justify;'>Из вышесказанного следует, что общий способ организовать 
  сети с нескольки­ми сегментами - это назначить каждому сегменту свой идентификатор 
  сети. Но у этого решения есть недостатки. Во-первых, при этом возможна потеря 
  многих адресов в каждой сети. Так, если у любого сегмента сети имеется свой 
  адрес класса В, то большая часть IP-адресов просто не будет использоваться.</p>
<p style='text-align:justify;'>Во-вторых, маршрутная таблица любого узла, который 
  направляет датаграммы напрямую в комбинированную сеть, должна содержать по одной 
  записи для каждого сегмента. В указанном примере это не так страшно. Но вообразите 
  сеть из нескольких сотен сегментов, а таких сетей может быть много. Понятно, 
  что разме­ры маршрутных таблиц станут громадными.</p>
<p style='text-align:justify;'><i>Примечание:</i> Эта проблема более серьезна, 
  чем может показаться на первый взгляд. Объем памяти маршрутизаторов обычно ограничен, 
  и нередко маршрутные таблицы размещаются в памяти специального назначения на 
  сетевых картах. Реальные примеры отказа маршрутизаторов из-за роста маршрутных 
  таблиц рассматриваются в работе [Huitema 1995].</p>
<p style='text-align:justify;'>Обратите внимание, что эти проблемы не возникают 
  при наличии хотя бы одного идентификатора сети. IP-адреса не остаются неиспользованными, 
  поскольку при потребности в новых хостах можно всегда добавить новый сегмент. 
  С другой стороны, так как имеется лишь один идентификатор сети, в любой маршрутной 
  таблице необходима всего одна запись для отправки датаграмм любому хосту в этой 
  сети.</p>
<h2><a name="p2">Подсети</a></h2>
<p style='text-align:justify;'>Мне хотелось найти решение, сочетающее два достоинства: 
  во-первых, небольшие маршрутные таблицы и эффективное использование адресного 
  пространства, обеспечиваемые единым идентификатором сети, во-вторых, простота 
  маршрутизации, характерная для сетей, имеющих сегменты с разными идентификаторами 
  сети. Желательно, чтобы внешние хосты «видели» только одну сеть, а внутрен­ние 
  - несколько сетей, по одной для каждого сегмента.</p>
<p style='text-align:justify;'>Это достигается с помощью механизма подсетей. Идея 
  очень проста. Поскольку внешние хосты для принятия решения о выборе маршрута 
  используют только идентификатор сети, администратор может распределять идентификаторы 
  хостов по своему усмотрению. Таким образом, идентификатор хоста - это закрытая 
  структура, не имеющая вне данной сети интерпретации.</p>
<p style='text-align:justify;'>Разделение на подсети осуществляется по следующему 
  принципу. Одна часть идентификатора хоста служит для определения сегмента (то 
  есть подсети), в состав которого входит хост, а другая - для идентификации конкретного 
  хоста. Рассмотрим, например, сеть класса B с адресом 190.50.0.0. Можно считать, 
  что третий байт адреса - это идентификатор подсети, а четвертый байт - номер 
  хоста в этой подсети. На рис. 2.6а приведена структура адреса с точки зрения 
  внешнего компьютера. Идентификатор хоста&nbsp;- это поле с заранее неизвестной 
  структурой. На рис. 2.6б показано, как эта структура выглядит изнутри сети. 
  Вы видите, что она состоит из идентификатора подсети и номера хоста.</p>
<p align=center style='text-align:center;'> <img width=356 height=114
src="./img/image009.gif" v:shapes="_x0000_i1029"> </p>
<p align=center style='text-align:center;'>Рис. 2.6. Два взгляда на адрес сети 
  класса B с подсетями</p>
<p style='text-align:justify;'>В приведенном примере взят адрес класса В, и поле 
  номера хоста выделено по границе байта. Но это необязательно. На подсети можно 
  разбивать сети классов А, В и С и часто не по границе байта. С каждой подсетью 
  ассоциируется маска подсети, которой определяется, какая часть адреса отведена 
  под идентификаторы сети I и подсети, а какая&nbsp;- под номер хоста. Так, маска 
  подсети для примера, показанного на рис. 2.6б, будет 0xffffff00. В основном 
  маска записывается в десятичной нотации (255.255.255.0), но если разбивка проходит 
  не по границе байта, то удобнее первая форма.</p>
<p style='text-align:justify;'><i>Примечание:</i> Обратите внимание, что, хотя 
  говорится о маске подсети, фактически она выделяет части, относящиеся как к 
  сети, так и к подсети, то есть все, кроме номера хоста.</p>
<p style='text-align:justify;'>Предположим, что для иде                         
  нтификатора подсети отведено 10 бит, а для номера хоста&nbsp;- 6 бит. Тогда 
  маска подсети будет 255.255.255.192 (0xffffffc0). Как следует из рис. 2.7, в 
  результате наложения этой маски на адрес 190.50.7.75 получается номер сети/подсети, 
  равный 190.70.7.64.</p>
<p style='text-align:justify;'>Для проверки убедитесь, что адрес 190.50.7.75 принадлежит 
  хосту 11 в подсети 29 сети 190.50.0.0. Важно не забывать, что эта интерпретация 
  имеет смысл только внутри сети. Для внешнего мира адрес интерпретируется как 
  хост 1867 в сети 190.50.0.0.</p>
<p style='text-align:justify;'>Теперь следует выяснить, как маршрутизаторы на 
  рис. 2.5 могут воспользоваться структурой идентификатора хоста для рассылки 
  датаграмм внутри сети. Предположим, что есть сеть класса В с адресом 190.5.0.0 
  и маска подсети равна 255.255.255.0. Такая структура показана на рис. 2.6б.</p>
<p align=center style='text-align:center;'> <img width=428 height=129
src="./img/image010.gif" v:shapes="_x0000_i1031"> </p>
<p align=center style='text-align:center;'>Рис. 2.7. Наложение маски подсети с 
  помощью операции AND для выделения сетевой части IP&nbsp;- адреса</p>
<p style='text-align:justify;'>На рис. 2.8 первому сегменту назначен идентификатор 
  подсети 1, а второму&nbsp;- идентификатор подсети 2. Рядом с сетевым интерфейсом 
  каждого хоста указан его IP&nbsp;-адрес. Обратите внимание, что третий байт 
  каждого адреса&nbsp;- это номер подсети, которой принадлежит интерфейс. Однако 
  внешнему компьютеру эта интерпретация неизвестна.</p>
<p align=center style='text-align:center;'> <img width=416 height=232
src="./img/image011.gif" v:shapes="_x0000_i1028"> </p>
<p align=center style='text-align:center;'>Рис. 2.8. Сеть с подсетями</p>
<p style='text-align:justify;'>Возвращаясь к вышесказанному, следует выяснить, 
  что происходит, когда хосту H1 нужно обратиться к хосту Н3. H1 берет адрес Н3 
  (190.50.2.1) и накладывает на него маску подсети (255.255.255.0), получая в 
  результате 190.5.2.0. Поскольку H1 находится в подсети 190.5.1.0, то Н3 напрямую 
  недоступен, поэтому он сверяется со своей маршрутной таблицей и обнаруживает, 
  что следующий адрес на пути к Н3&nbsp;- это R1.</p>
<p style='text-align:justify;'><i>Примечание: </i>Во многих реализациях эти два 
  шага объединены за счет помещения в маршрутную таблицу обеих подсетей. При поиске 
  маршрута IP выявляет одно из двух: либо целевая сеть доступна непосредственно, 
  либо датаграмму надо отослать промежуточному маршрутизатору.</p>
<p style='text-align:justify;'>Затем H1 отображает IP&nbsp;- адрес R1 на его физический 
  адрес (например, с помощью протокола ARP) и посылает R1 датаграмму. R1 ищет 
  адрес назначения в своей маршрутной таблице, пользуясь той же маской подсети, 
  и определяет местонахождение НЗ в подсети, соединенной с его интерфейсом 190.50.2.4. 
  После чего R1 доставляет датаграмму хосту НЗ, получив предварительно его физический 
  адрес по IP-адресу, - для этого достаточно передать датаграмму сетевому интерфейсу 
  190.50.2.4.</p>
<p style='text-align:justify;'>А теперь предположим, что H1 необходимо отправить 
  датаграмму Н2. При наложении маски подсети на адрес Н2 (190.5.1.2) получается 
  190.50.1.0, то есть та же подсеть, в которой находится сам хост H1. Поэтому 
  H1 нужно только получить физический адрес Н2 и отправить ему датаграмму напрямую.</p>
<p style='text-align:justify;'>Далее разберемся, что происходит, когда хосту Е 
  из внешней сети нужно отправить датаграмму Н3. Поскольку 190.50.2.1 - адрес 
  класса В, то маршрутизатору на границе сети хоста Е известно, что Н3 находится 
  в сети 190.50.0.0. Так как шлюзом в эту сеть является R2, рано или поздно датаграмма 
  от хоста Е дойдет до этого маршрутизатора. С этого момента все совершается так 
  же, как при отправке датаграммы хостом H1: R2 накладывает маску, выделяет адрес 
  подсети 190.50.2.0, определяет R1 в качестве следующего узла на пути к Н3 и 
  посылает R1 датаграмму, которую тот переправляет Н3. Заметьте, что хосту Е неизвестна 
  внутренняя топология сети 190.50.0.0. Он просто посылает датаграмму шлюзу R2. 
  Только R2 и другие хосты внутри сети определяют существование подсетей и маршруты 
  доступа к ним.</p>
<p style='text-align:justify;'>Важный момент, который нужно помнить,&nbsp;- маска 
  подсети ассоциируется с сетевым интерфейсом и, следовательно, с записью в маршрутной 
  таблице. Это означает, что разные подсети в принципе могут иметь разные маски.</p>
<p style='text-align:justify;'>Предположим, что адрес класса В 190.50.0.0 принадлежит 
  университетской сети, а каждому факультету выделена подсеть с маской 255.255.255.0 
  (на рис. 2.8 показана только часть всей сети). Администратор факультета информатики, 
  которому назначена подсеть 5, решает выделить один сегмент сети Ethernet компьютерному 
  классу, а другой&nbsp;- всем остальным факультетским компьютерам. Он мог бы 
  потребовать у администрации университета еще один номер подсети, но в компьютер­ном 
  классе всего несколько машин, так что нет смысла выделять ему адресное про­странство, 
  эквивалентное целой подсети класса С. Вместо этого он предпочел разбить свою 
  подсеть на два сегмента, то есть создать подсеть внутри подсети.</p>
<p style='text-align:justify;'>Для этого он увеличивает длину поля подсети до 
  10 бит и использует маску 255.255.255.192. В результате структура адреса выглядит, 
  как показано на рис. 2.9.</p>
<p style='text-align:justify;'>Старшие 8 бит идентификатора подсети всегда равны 
  0000 0101 (5), поскольку основная сеть адресует всю подсеть как подсеть 5. Биты 
  X и Y определяют, какой Ethernet-сегмент внутри подсети 190.50.5.0 адресуется. 
  Из рис. 2.10 видно, что если XY = 10, то адресуется подсеть в компьютерном классе, 
  а если XY = 01&nbsp;- оставшаяся часть сети. Частично топология подсети 190.50.5.0 
  изображена на рис. 2.10.</p>
<p align=center style='text-align:center;'> <img width=365 height=91
src="./img/image012.gif" v:shapes="_x0000_i1026"> </p>
<p align=center style='text-align:center;'>Рис. 2.9. Структура адреса для подсети 
  190.50.5.0</p>
<p style='text-align:justify;'>В верхнем сегменте (подсеть 190.50.1.0) на рис. 
  2.10 расположен маршрутизатор R2, обеспечивающий выход во внешний мир, такой 
  же, как на рис. 2.8. Под сеть 190.50.2.0 здесь не показана. Средний сегмент 
  (подсеть 190.50.5.128)&nbsp;- это локальная сеть Ethernet в компьютерном классе. 
  Нижний сегмент (подсеть 190.50.5.64)&nbsp;- это сеть Ethernet, объединяющая 
  остальные факультетские компьютеры. Для упрощения номер хоста каждой машины 
  один и тот же для всех ее сетевых интерфейсов и совпадает с числом внутри прямоугольника, 
  представляющего хост или маршрутизатор.</p>
<p align=center style='text-align:center;'> <img width=557 height=256
src="./img/image013.gif" v:shapes="_x0000_i1027"> </p>
<p align=center style='text-align:center;'>Рис. 2.10. Подсеть внутри подсети</p>
<p style='text-align:justify;'>Маска подсети для интерфейсов, подсоединенных к 
  подсетям 190.50.5.64 и 190.50.5.128, равна 255.255.255.192, а к подсети 190.50.1.0&nbsp;- 
  255.255.255.0.</p>
<p style='text-align:justify;'>Эта ситуация в точности аналогична предыдущей, 
  которая рассматривалась для рис. 2.8. Так же, как хостам вне сети 190.50.0.0 
  неизвестно то, что третий байт адреса определяет подсеть, так и хосты в сети 
  190.50.0.0, но вне подсети 190.50.5.0, не могут определить, что первые два бита 
  четвертого байта задают подсеть подсети 190.50.5.0.</p>
<p style='text-align:justify;'>Теперь кратко остановимся на широковещательных 
  адресах. При использовании подсетей существует четыре типа таких адресов для 
  вещания: ограниченный, на сеть, на подсеть и на все подсети.</p>
<h2><a name="p3">Ограниченное вещание</a></h2>
<p style='text-align:justify;'>Адрес для ограниченного вещания - 255.255.255.255. 
  Вещание называется ограниченным, поскольку датаграммы, посланные на этот адрес, 
  не уходят дальше маршрутизатора. Они ограничены локальным кабелем. Такое широковещание 
  применяется, главным образом, во время начальной загрузки, если хосту неизвестен 
  свой IP-адрес или маска своей подсети.</p>
<p style='text-align:justify;'>Процесс передачи широковещательной датаграммы хостом, 
  имеющим несколько сетевых интерфейсов, зависит от реализации. Во многих реализациях 
  датаграмма отправляется только по одному интерфейсу. Чтобы приложение отправил 
  широковещательную датаграмму по нескольким интерфейсам, ему необходим узнать 
  у операционной системы, какие интерфейсы сконфигурированы для поддержки широковещания.</p>
<h2><a name="p4">Вещание на сеть</a></h2>
<p style='text-align:justify;'>В адресе для вещания на сеть идентификатор сети 
  определяет адрес этой сети, а идентификатор хоста состоит из одних единиц. Например, 
  для вещания на сет 190.50.0.0 используется адрес 190.50.255.255. Датаграммы, 
  посылаемые на такой адрес, доставляются всем хостам указанной сети.</p>
<p style='text-align:justify;'>Требования к машрутизаторам (RFC 1812) [Baker 1995] 
  предусматривают по умолчанию пропуск маршрутизатором сообщений, вещаемых на 
  сеть, но эту возможность можно отключить. Во избежание атак типа «отказ от обслуживания» 
  (denial of service), которые используют возможности, предоставляемые направленным 
  широковещанием, во многих маршрутизаторах пропуск таких датаграмм, скорее всего, 
  будет заблокирован.</p>
<h2><a name="p5">Вещание на подсеть</a></h2>
<p style='text-align:justify;'>В адресе для вещания на все подсети идентификаторы 
  сети и подсети определяют соответствующие адреса, а идентификатор хоста состоит 
  из одних единиц. Не зная маски подсети, невозможно определить, является ли данный 
  адрес адресом для вещания на подсеть. Например, адрес 190.50.1.255 можно трактовать 
  как адрес для вещания на подсеть только при условии, если маршрутизатор имеет 
  информацию, что маска подсети равна 255.255.255.0. Если же известно, что маска 
  подсети равна 255.255.0.0, то это адрес не считается широковещательным.</p>
<p style='text-align:justify;'>При использовании бесклассовой междоменной маршрутизации 
  (CIDR), которая будет рассмотрена ниже, широковещательный адрес этого типа такой 
  же, как и адрес вещания на сеть; RFC 1812 предлагает трактовать их одинаково.</p>
<h2><a name="p6">Вещание на все подсети</a></h2>
<p style='text-align:justify;'>В адресе для вещания на все подсети задан идентификатор 
  сети, а адреса подсети и хоста состоят из одних единиц. Как и при вещании на 
  подсеть, для опознания такого адреса необходимо знать маску подсети.</p>
<p style='text-align:justify;'>К сожалению, применение адреса для вещания на все 
  подсети сопряжено с н которыми проблемами, поэтому этот режим не внедрен. При 
  использовали CIDR этот вид широковещания не нужен и, по RFC 1812, «отправлен 
  на свалку истории».</p>
<p style='text-align:justify;'>Ни один из описанных широковещательных адресов 
  нельзя использовать в качестве адреса источника IP-датаграммы. И, наконец, следует 
  отметить, что в некоторых ранних реализациях TCP/IP, например в системе 4.2BSD, 
  для выделения широковещательного адреса в поле идентификатора хоста ставились 
  не единицы, а нули.</p>
<h2><a name="p7">Бесклассовая междоменная маршрутизация&nbsp;- </a>CIDR</h2>
<p style='text-align:justify;'>Теперь вам известно, как организация подсетей решает 
  одну из проблем, связанных с классами адресов: переполнение маршрутных таблиц. 
  Хотя и в меньшей степени, подсети все же позволяют справиться и с проблемой 
  истощения IP&nbsp;- адресов за счет лучшего использования пула идентификаторов 
  хостов в пределах одной сети.</p>
<p style='text-align:justify;'>Еще одна серьезная проблема - это недостаток сетей 
  класса В. Как показано на рис. 2.5, существует менее 17000 таких сетей. Поскольку 
  большинство средних и крупных организаций нуждается в количестве IP-адресов, 
  превышающем возможности сети класса С, им выделяется идентификатор сети класса 
  В.</p>
<p style='text-align:justify;'>В условиях дефицита сетей класса В организациям 
  приходилось выделять бло­ки адресов сетей класса С, но при этом вновь возникает 
  проблема, которую пытались решить с помощью подсетей, - растут маршрутные таблицы.</p>
<p style='text-align:justify;'>Бесклассовая междоменная маршрутизация (CIDR) решает 
  эту проблему, вывернув принцип организации подсетей «наизнанку». Вместо увеличения 
  CIDR уменьшает длину идентификатора сети в IP-адресе.</p>
<p style='text-align:justify;'>Предположим, некоторой организации нужно 1000 IP-адресов. 
  Ей выделяют четыре соседних идентификатора сетей класса С с общим префиксом 
  от 200.10.4.0 до 200.10.7.0. Первые 22 бита этих идентификаторов одинаковы и 
  представляют номер агрегированной сети, в данном случае 200.10.4.0. Как и для 
  подсетей, для идентификации сетевой части IP-адреса используется маска сети. 
  В приведенном здесь примере она равна 255.255.252.0 (0xfffffc00).</p>
<p style='text-align:justify;'>Но в отличие от подсетей эта маска сети не расширяет 
  сетевую часть адреса, а укорачивает ее. Поэтому CIDR называют также суперсетями. 
  Кроме того, маска сети в отличие от маски подсети экспортируется во внешний 
  мир. Она становится частью любой записи маршрутной таблицы, ссылающейся на данную 
  сеть.</p>
<p style='text-align:justify;'>Допустим, внешнему маршрутизатору R надо переправить 
  датаграмму по адресу 200.10.5.33, который принадлежит одному из хостов в агрегированной 
  сети. Он просматривает записи в своей маршрутной таблице, в каждой из которых 
  хранятся маска сети, и сравнивает замаскированную часть адреса 200.10.5.33 с 
  хранящимся в записи значением. Если в таблице есть запись для сети, то в ней 
  будет храниться адрес 200.10.4.0 и маска сети 255.255.252.0. Когда выполняется 
  операция побитового AND между адресом 200.10.5.33 и этой маской, получается 
  значение 200.10.4.0. Это значение совпадает с хранящимся в записи номером подсети, 
  так что маршрутизатору известно, что именно по этому адресу следует переправить 
  датаграмму.</p>
<p style='text-align:justify;'>Если возникает неоднозначность, то берется самое 
  длинное соответствие. Например, в маршрутной таблице может быть также запись 
  с адресом 200.10.0.0 и маской сети 255.255.0.0. Эта запись также соответствует 
  адресу 200.10.5.33, но, поскольку для нее совпадают только 16 бит, а не 22, 
  как в первом случае, то предпочтение отдается первой записи.</p>
<p style='text-align:justify;'><i>Примечание:</i> Может случиться так, что Internet 
  сервис&nbsp;- провайдер (ISP) «владеет» всеми IP-адресами с префиксом 200.10. 
  В соответствии со второй из рассмотренных выше записей маршрутизатор отправил 
  бы этому провайдеру все датаграммы, адрес назначения которых начинается с 200.10. 
  Тогда провайдер смог бы указать более точный маршрут, чтобы избежать лишних 
  звеньев в маршруте или по какой-то иной причине.</p>
<p style='text-align:justify;'>В действительности механизм CIDR более общий. Он 
  называется «бесклассовым», так как понятие «класса» в нем полностью отсутствует. 
  Таким образом, каждая запись в маршрутной таблице содержит маску сети, определяющую 
  сетевую часть IP-адреса. Если принять, что адрес принадлежит некоторому классу, 
  то эта маска может укоротить или удлинить сетевую часть адреса. Но поскольку 
  в CIDR понятия «класса» нет, то можно считать, что сетевая маска выделяет сетевую 
  часть адреса без изменения ее длины.</p>
<p style='text-align:justify;'>В действительности, маска - это всего лишь число, 
  называемое префиксом, которое определяет число бит в сетевой части адреса. Например, 
  для выше упомянутой агрегированной сети префикс равен 22, и адрес этой сети 
  следовало бы записать как 200.10.4.0/22, где /22 обозначает префикс. С этой 
  точки зрения адресацию на основе классов можно считать частным случаем CIDR, 
  когда имеется всего четыре (или пять) возможных префиксов, закодированных в 
  старших битах адреса.</p>
<p style='text-align:justify;'>Гибкость, с которой CIDR позволяет задавать размер 
  адреса сети, позволяет эффективно распределять IP-адреса блоками, размер которых 
  оптимально соответствует потребностям сети. Вы уже видели, как можно использовать 
  CIDR для агрегирования нескольких сетей класса С в одну большую сеть. А для 
  организации маленькой сети из нескольких хостов можно выделить лишь часть адресов 
  сети класса С. Например, сервис&nbsp;- провайдер выделяет небольшой компании 
  с единственной ЛВС адрес сети 200.50.17.128/26. В такой сети может существовать 
  до 62 хостов (2^6-2).</p>
<p style='text-align:justify;'>В RFC 1518 [Rekhter и Li 1993] при обсуждении вопроса 
  об агрегировании адресов и его влиянии на размер маршрутных таблиц рекомендуется 
  выделять префиксы IP-адресов (то есть сетевые части адреса) иерархически.</p>
<p style='text-align:justify;'><i>Примечание:</i> Иерархическое агрегирование 
  адресов можно сравнить с иерархической файловой системой вроде тех, что используют 
  в UNIX и Windows. Так же, как каталог верхнего уровня содержит информацию о 
  своих подкаталогах, но не имеет сведений о находящихся в них файлах, доменам 
  маршрутизации верхнего уровня известно лишь о промежуточных доменах, а не о 
  конкретных сетях внутри них. Предположим, что региональный провайдер обеспечивает 
  весь трафик для префикса 200/8, а к нему подключены три локальных провайдера 
  с префиксами 200.1/16,200.2/16 и 200.3/16. У каждого провайдера есть несколько 
  клиентов, которым выделены части располагаемого адресного пространства (200.1.5/24 
  и т.д.). Маршрутизаторы, внешние по отношению к региональному провайдеру, должны 
  хранить в своих таблицах только одну запись&nbsp;- 200/8. Этого достаточно для 
  достижения любого хоста в данном диапазоне адресов. Решения о выборе маршрута 
  можно принимать, даже не зная о разбиении адресного пространства 200/8. Маршрутизатор 
  регионального провайдера должен хранить в своей таблице только три записи: по 
  одной для каждого локального провайдера. На самом нижнем уровне локальный провайдер 
  хранит записи для каждого своего клиента. Этот простой пример позволяет видеть 
  суть агрегирования.</p>
<p style='text-align:justify;'>Почитать RFC 1518 очень полезно, поскольку в этом 
  документе демонстриру­ются преимущества использования CIDR. В RFC 1519 [Fuller 
  et al. 1993] описаны CIDR и ее логическое обоснование, а также приведены подробный 
  анализ затрат, связанных с CIDR, и некоторые изменения, которые придется внести 
  в протоколы междоменной маршрутизации.</p>
<h2><a name="p8">Текущее состояние организации подсетей и </a>CIDR</h2>
<p style='text-align:justify;'>Подсети в том виде, в каком они описаны в RFC 950 
  [Mogul and Postel 1985],&nbsp;-это часть Стандартного протокола (Std. 5). Это 
  означает, что каждый хост, на котором установлен стек TCP/IP, обязан поддерживать 
  подсети.</p>
<p style='text-align:justify;'>CIDR (RFC 1517 [Hinden 1993], RFC 1518, RFC 1519)&nbsp;- 
  часть предложений к стандартному протоколу, и потому не является обязательной. 
  Тем не менее CIDR применяется в Internet почти повсеместно, и все новые адреса 
  выделяются этим способом. Группа по перспективным разработкам в Internet (IESG 
  - Internet Engineering Steering Group) выбрала CIDR как промежуточное временное 
  решение проблемы роста маршрутных таблиц.</p>
<p style='text-align:justify;'>В перспективе обе проблемы - исчерпания адресов 
  и роста маршрутных таблиц&nbsp;- предполагается решать с помощью версии 6 протокола 
  IP. IPv6 имеет большее адресное пространство (128 бит) и изначально поддерживает 
  иерархию. Такое адресное пространство (включая 64 бита для идентификатора интерфейса) 
  гарантирует, что вскоре IP-адресов будет достаточно. Иерархия IРv6-адресов позволяет 
  держать размер маршрутных таблиц в разумных пределах.</p>
<h3><a name="p9">Резюме</a></h3>
<p style='text-align:justify;'>В этом разделе рассмотрены подсети и бесклассовая 
  междоменная маршрутизация (CIDR). Вы узнали, как они применяются для решения 
  двух проблем, свойственных адресации на основе классов. Подсети позволяют предотвратить 
  рост маршрутных таблиц, обеспечивая в то же время гибкую адресацию. CIDR служит 
  эффективного выделения IP-адресов и способствует их иерархическому назначению.</p>
<hr><div align="right"><a href="adv2.htm#top">Вверх</a> | <a href="index.htm">Содержание</a> | <a href="adv1.htm">Назад</a> | <a href="adv3.htm">Далее</a></div>
</body>
</html>
