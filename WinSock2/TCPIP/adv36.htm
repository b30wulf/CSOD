<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<link href="style.css" type="text/css" rel=stylesheet>
<title>Совет 36</title>
</head>
<body lang=RU link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">
<h2><a name="top">Совет 36. Используйте программу </a>ttcp</h2>
<hr><div align="right"><a href="adv36.htm#p1">Вниз</a> | <a href="index.htm">Содержание</a> | <a href="adv35.htm">Назад</a> | <a href="adv37.htm">Далее</a></div>
<p style='text-align:justify;'>Часто необходимо иметь утилиту, которая может посылать 
  произвольный объем данных другой (или той же самой) машине по протоколу TCP 
  или UDP и собирать статистическую информацию о полученных результатах. В этой 
  книге уже написано несколько программ такого рода. В этом разделе вы познакомитесь 
  с готовым инструментом, обладающим той же функциональностью. Подобное средство 
  можно использовать для тестирования собственного приложения или для получения 
  информации о производительности конкретного стека TCP/IP или сети. Такая информация 
  может оказаться бесценной на этапе создания прототипа.</p>
<p style='text-align:justify;'>Этот инструмент - программа ttcp, бесплатно распространяемая 
  Лабораторией баллистических исследований армии США (BRL - Ballistics Research 
  Laboratory). Ее авторы Майк Муусс (автор программы ping) и Терри Слэттери. Эта 
  утилита доступна на множестве сайтов в Internet. В книге будет использована 
  версия, которую Джон Лин модифицировал с целью включения дополнительной статистики; 
  ее можно получить по анонимному FTP с сайта gwen.cs.purdue.edu из каталога /pub/lin. 
  Версия без модификаций Лина находится, например, на сайте ftp.sgi.com в каталоге 
  sgi/ src/ttcp, в состав ее дистрибутива входит также страница руководства.</p>
<p style='text-align:justify;'>У программы ttcp есть несколько опций, позволяющих 
  управлять: объемом Посылаемых данных, длиной отдельных операций записи и считывания, 
  размерами буферов приема и передачи сокета, включением или отключением алгоритма 
  Нейгла и даже выравниванием буферов в памяти. На рис. 4.11 приведена информация 
  о порядке использования ttcp. Дается перевод на русский язык, хотя оригинальная 
  программа, естественно, выводит справку по-английски.</p>
<p>Порядок вызова:ttcp -t [-опции] хост [ &lt; in ]</p>
<p>               ttcp -r [-опции &gt; out]</p>
<p>Часто используемые опции:</p>
<p class=MsoBodyTextIndent3 style='line-height:normal'>-1 ## длина в байтах буферов, 
  в которые происходит считывание из  сети и запись в сеть (по умолчанию 8192)</p>
<p style='
'>-u использовать UDP, а не TCP</p>
<p>-p ## номер порта, в который надо посылать данные или прослушивать (по умолчанию 
  5001)</p>
<p style='
'>-s -t: отправить данные в сеть</p>
<p style='
'>   -r: считать (и отбросить) все данные из сети</p>
<p>-А выравнивать начало каждого буфера на эту границу(по умолчанию 16384)</p>
<p>-O считать, что буфер начинается с этого смещения относительно границы (по 
  умолчанию 0)</p>
<p>-v печатать более подробную статистику</p>
<p style='
'>-d установить опцию сокета SO_DEBUG</p>
<p>-b ## установить размер буфера сокета (если поддерживает операционная система)</p>
<p>-f X формат для вычисления скорости обмена: к,К = кило (бит, байт);</p>
<p>               m,М = мега; g,G = гига</p>
<p>Опции, употребляемые вместе с -t:</p>
<p>-n ## число буферов, записываемых в сеть (по умолчанию 2048)</p>
<p>-D не буферизовать запись по протоколу TCP (установить опцию сокета TCP_NODELAY)</p>
<p>Опции, употребляемые вместе с -r:</p>
<p>-В для -s, выводить только полные блоки в соответствии с опцией -1 (для TAR)</p>
<p>-Т &quot;touch&quot;: обращаться к каждому прочитанному байту</p>
<p align=center style='text-align:center;'>Рис. 4.11. Порядок вызова ttcp</p>
<p style='text-align:justify;'>Поэкспериментируем с размером буфера передачи сокета. 
  Сначала прогоним тест с размером буфера, выбранным по умолчанию, чтобы получить 
  точку отсче В одном окне запустим экземпляр ttcp-потребителя:</p>
<p style='text-align:justify'>bsd: $ ttcp –rsv</p>
<p style='text-align:justify'>а в другом - экземпляр, играющий роль источника:</p>
<p style='text-align:justify;'>bsd: $ ttcp -tsv bsd</p>
<p style='text-align:justify'>ttcp-t: buflen=8192, nbuf=2048, align=16384/0, port=5013 
  tcp -&gt; bsd</p>
<p style='text-align:justify'>ttcp-t: socket</p>
<p style='text-align:justify'>ttcp-t: connect</p>
<p style='text-align:justify'>ttcp-t: 16777216 bytes in 1.341030 real seconds</p>
<p style='text-align:justify;'>= 12217.474628 KB/sec (95.449021 Mb/sec)</p>
<p style='text-align:justify'>ttcp-t: 16777216 bytes in 0.00 CPU seconds</p>
<p style='text-align:justify;'>= 16384000.000000 KB/cpu sec</p>
<p style='text-align:justify'>ttcp-t: 2048 I/O calls, msec/call = 0.67, calls/sec 
  = 1527.18</p>
<p style='text-align:justify'>ttcp-t: buffer address 0x8050000</p>
<p style='text-align:justify'>bsd: $</p>
<p style='text-align:justify;'>Как видите, ttcp дает информацию о производительности. 
  Для передачи 16 Мб потребовалось около 1,3 с.</p>
<p style='text-align:justify;'><i>Примечание:</i> Аналогичная статистика печатается 
  принимающим процессом, но поскольку цифры, по существу, такие же, они здесь 
  не приводятся.</p>
<p style='text-align:justify;'>Также был выполнен мониторинг обмена с помощью 
  tcpdump. Вот типичная строка выдачи:</p>
<p style='text-align:justify'>13:05:44.084576 bsd.1061 &gt;  bsd.5013: . 1:1449(1448)</p>
<p style='text-align:justify;'>ack Iwinl7376 &lt;nop,nop,timestamp 11306 11306&gt; 
  (DF)</p>
<p style='text-align:justify;'>Из нее видно, что TCP посылает сегменты по 1448 
  байт. Теперь следует установить размер буфера передачи равным 1448 байт, и по­вторить 
  эксперимент. Приемник данных нужно оставить без изменения.</p>
<p style='text-align:justify'>bsd: $ ttcp -tsvb 1448 bsd</p>
<p style='text-align:justify'>ttcp-t: socket</p>
<p style='text-align:justify'>ttcp-t: sndbuf</p>
<p style='text-align:justify'>ttcp-t: connect</p>
<p style='text-align:justify'>ttcp-t: buflen=8192, nbuf=2048, align=16384/0, port=5013,</p>
<p style='text-align:justify'>sockbufsize=1448 tcp -&gt; bsd</p>
<p style='text-align:justify'>ttcp-t: 16777216 bytes in 2457.246699 real seconds</p>
<p style='text-align:justify;'>= 6.667625 KB/sec (0.052091 Mb/sec)</p>
<p style='text-align:justify'>ttcp-t: 16777216 bytes in 0.00 CPU seconds</p>
<p style='text-align:justify;'>= 16384000.000000 KB/cpu sec</p>
<p style='text-align:justify'>ttcp-t: 2048 I/O calls, msec/call = 1228.62, calls/sec 
  = 0.83 ttcp-t: buffer address 0x8050000</p>
<p style='text-align:justify'>bds: $</p>
<p style='text-align:justify;'>На этот раз передача заняла почти 41 мин. Следует 
  отметить, что, хотя по часам для передачи потребовалось больше 40 мин, время, 
  затраченное процессором, Попрежнему очень мало, даже не поддается измерению. 
  Поэтому, что бы ни произошло, это не связано с загрузкой процессора.</p>
<p style='text-align:justify;'>Теперь посмотрим, что показывает tcpdump. На рис. 
  4.12 приведены четыре типичные строки:</p>
<p>16:03:57.168093 bsd.1187 &gt; bsd.5013: Р 8193:9641(1448)</p>
<p>ack 1 win 17376 &lt;nор,ор,timestamp 44802 44802&gt; (DF)</p>
<p>16:03:57.368034 bsd.5013 &gt; bsd.1187: . ack 9641 win 17376</p>
<p>&lt;nop,nор,timestamp 44802 44802&gt; (DF)</p>
<p>16:03:57.368071 bsd.1187. &gt; bsd.5013: P 9641:11089(1448)</p>
<p>ack 1 win;17376 &lt;nop,nор,timestamp 44802 44802&gt; (DF)</p>
<p>16:03:57.568038 bsd.5013 &gt; bsd. 1187: .ack 11089 win 17376</p>
<p>&lt;nop,nор,timestamp 44802 44802&gt; (DF)</p>
<p align=center style='text-align:center;'>Рис. 4.12. Типичная выдача tcpdump 
  для запуска ttcp -tsvb 1448 bsd</p>
<p style='text-align:justify;'>Обратите внимание, что время между последовательными 
  сегментами составляет почти 200 мс. Возникает подозрение, что тут замешано взаимодействие 
  между алгоритмами Нейгла и отложенного подтверждения (совет 24). И действительно 
  именно АСК задерживаются.</p>
<p style='text-align:justify;'>Эту гипотезу можно проверить, отключив алгоритм 
  Нейгла с помощью опции&nbsp;-D. Повторим эксперимент:</p>
<p style='text-align:justify'>bsd: $ ttcp -tsvDb 1448 bsd</p>
<p style='text-align:justify'>ttcp-t: buflen=8192, nbuf=2048, align=16384/0, port=5013,</p>
<p style='text-align:justify;'>sockbufsize=1448 tcp -&gt; bsd ttcp-t  socket ttcp-t  
  sndbuf ttcp-t: connect</p>
<p style='text-align:justify'>ttcp-t: nodelay</p>
<p style='text-align:justify'>ttcp-t: 16777216 bytes in 2457.396882 real seconds</p>
<p style='text-align:justify;'>= 6.667218 KB/sec (0.052088 Mb/sec)</p>
<p style='text-align:justify'>ttcp-t: 16777216 bytes in 0.00 CPU seconds</p>
<p style='text-align:justify;'>= 16384000.000000 KB/cpu sec</p>
<p style='text-align:justify'>ttcp-t: 2048 I/O calls, msec/call = 1228.70, calls/sec 
  = 0.83 ttcp-t: buffer address 0x8050000</p>
<p style='text-align:justify'>bds: $</p>
<p style='text-align:justify;'>Как ни странно, ничего не изменилось.</p>
<p style='text-align:justify;'><i>Примечание:</i> Это пример того, как опасно 
  делать поспешные заключения. Стоило немного подумать и стало бы ясно, что алгоритм 
  Нейгла тут ни при чем, так как посылаются заполненные сегменты. В частности, 
  этому служит самый первый тест, - чтобы определить величину MSS.</p>
<p style='text-align:justify;'>В совете 39 будут рассмотрены средства трассировки 
  системных вызовов. Тогда вы вернетесь к этому примеру и обнаружите, что выполняемая 
  ttcp операция записи не возвращает управление в течение примерно 1,2 с. Косвенное 
  указание на это видно и из выдачи ttcp, где каждый вызов операции ввода/вывода 
  занимает приблизительно 1,228 мс. Но, как говорилось в совете 15, TCP обычно 
  не блокирует операции записи, пока буфер передачи не окажется заполненным. Таким 
  образом, становится понятно, что происходит. Когда ttcp записывает 8192 байта, 
  ядро копирует первые 1448 байт в буфер сокета, после чего блокирует процесс, 
  так как места в буфере больше нет. TCP посылает все эти байты в одном сегменте, 
  но послать больше не может, так как в буфере ничего не осталось.</p>
<p style='text-align:justify;'><i>Примечание:</i> Из рис. 4.12 видно, что дело 
  обстоит именно так, поскольку в каждом отправленном сегменте задан флаг PSH, 
  а стеки, берущие начало в системе BSD, устанавливают этот флаг только тогда, 
  когда выполненная операция передачи опустошает буфер.</p>
<p style='text-align:justify;'>Поскольку приемник данных ничего не посылает в 
  ответ, запускается механизм отложенного подтверждения, из-за которого АСК не 
  возвращается до истечения тайм-аута в 200 мс.</p>
<p style='text-align:justify;'>В первом тесте TCP мог продолжать посылать заполненные 
  сегменты данных, поскольку буфер передачи был достаточно велик (16 Кб на машине 
  bsd) для сохранения нескольких сегментов. Трассировка системных вызовов для 
  этого теста показывает, что на операцию записи уходит около 0,3 мс.</p>
<p class=MsoBodyTextIndent2>Этот пример наглядно демонстрирует, как важно, чтобы 
  буфер передачи отправителя был, по крайней мере, не меньше буфера приема получателя. 
  Хотя получатель был готов принимать данные и дальше, но в выходном буфере отправителя 
  задержался последний посланный сегмент. Забыть про него нельзя, пока не придет 
  АСК, говорящий о том, что данные дошли до получателя. Поскольку размер одного 
  сегмента значительно меньше, чем буфер приема (16 Кб), его получение не приводит 
  к обновлению окна (совет 15). Поэтому АСК задерживается на 200 мс. Подробнее 
  о размерах буферов рассказано в совете 32.</p>
<p style='text-align:justify;'>Однако смысл этого примера в том, чтобы показать, 
  как можно использовать ttcp для проверки эффекта установки тех или иных параметров 
  TCP-соединения. Вы также видели, как анализ информации, полученной от ttcp, 
  tcpdump и программы трассировки системных вызовов, может объяснить работу TCP.</p>
<p style='text-align:justify;'>Следует упомянуть о том, как использовать программу 
  ttcp для организации «сетевого конвейера» между хостами. Например, скопировать 
  всю иерархию каталогов с хоста А на хост В. На хосте В вводите команду</p>
<p style='text-align:justify'>ttcp -rB | tar -xpf -</p>
<p style='text-align:justify'>на хосте А - команду</p>
<p style='text-align:justify'>tar -cf - каталог | ttcp -t A</p>
<p style='text-align:justify;'>Можно распространить конвейер на несколько машин, 
  если на промежуточ­ных запустить команду</p>
<p style='text-align:justify'>ttcp -r | ttcp -t следующий_узел</p>
<h3><a name="p1">Резюме</a></h3>
<p style='text-align:justify;'>В этом разделе показано, как пользоваться программой 
  ttcp для экспериментирования с различными параметрами TCP-соединения, ttcp можно 
  применять также в целях тестирования собственных приложений, предоставляя для 
  них источник или приемник данных, работающий по протоколу TCP либо UDP. И, наконец, 
  вы видели, как использовать ttcp для организации сетевого конвейера между двумя 
  или более машинами.</p>
<hr><div align="right"><a href="adv36.htm#top">Вверх</a> | <a href="index.htm">Содержание</a> | <a href="adv35.htm">Назад</a> | <a href="adv37.htm">Далее</a></div>
</body>
</html>
