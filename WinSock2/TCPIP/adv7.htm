<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<link href="style.css" type="text/css" rel=stylesheet>
<title>Совет 7</title>
</head>
<body lang=RU link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">
<h2><a name="top">Совет 7. Не надо недооценивать производительность 
  </a>TCP</h2>
<hr><div align="right"><a href="adv7.htm#p3">Вниз</a> | <a href="index.htm">Содержание</a> | <a href="adv6.htm">Назад</a> | <a href="adv8.htm">Далее</a></div>
<p style='text-align:justify;'>TCP - это сложный протокол, обеспечивающий базовую 
  службу доставки IP&nbsp;- датаграмм надежностью и управлением потоком. В то 
  же время UDP добавляет лишь контрольную сумму. Поэтому может показаться, что 
  UDP должен быть на порядок быстрее TCP. Исходя из этого предположения, многие 
  программисты полагают, что с помощью UDP можно достичь максимальной производительности. 
  Да, действительно, есть ситуации, когда UDP существенно быстрее TCP. Но иногда 
  использование TCP оказывается эффективнее, чем применение UDP.</p>
<p style='text-align:justify;'>В сетевом программировании производительность любого 
  протокола зависит от сети, приложения, нагрузки и других факторов, из которых 
  не последнюю роль играет качество реализации. Единственный надежный способ узнать, 
  какой протокол и алгоритм работают оптимально,&nbsp;- это протестировать их 
  в предполагаешь условиях работы приложения. На практике это, конечно, не всегда 
  осуществимо, но часто удается получить представление о производительности, воспользовавшись 
  каркасами для построения простых программ, моделирующих ожидаемый сетевой трафик.</p>
<p style='text-align:justify;'>Перед созданием тестовых примеров необходимо разобраться, 
  когда и почему производительность UDP больше, чем TCP. Прежде всего, поскольку 
  TCP сложнее, он выполняет больше вычислений, чем UDP.</p>
<p style='text-align:justify;'><i>Примечание:</i> В работе [Stevens, 1996] сообщается, 
  что реализация TCP в системе 4.4 BSD содержит примерно 4500 строк кода на языке 
  С в сравнении с 800 строками для UDP. Естественно, обычно выполняется намного 
  меньше строк, но эти числа отражают сравнительную сложность кода.</p>
<p style='text-align:justify;'>Но в типичной ситуации большая часть времени процессора 
  в обоих протоколах тратится на копирование данных и вычисление контрольных сумм 
  (совет 26), поэтому здесь нет большой разницы. В своей работе [Partridge 1993] 
  Джекобсон описывает экспериментальную версию TCP, в которой для выполнения всего 
  кода обычно требуется всего 30 машинных инструкций RISC (исключая вычисление 
  контрольных сумм и копирование данных в буфер пользовательской программы, которые 
  производятся одновременно).</p>
<p style='text-align:justify;'>Нужно отметить, что для обеспечения надежности 
  TCP должен посылать подтверждения (АСК-сегменты) на каждый принятый пакет. Это 
  несколько увеличивает объем обработки на обоих концах. Во-первых, принимающая 
  сторона может включить АСК в состав данных, которые она посылает отправителю. 
  В действительности во многих реализациях TCP отправка АСК задерживается на несколько 
  миллисекунд: предполагается, что приложение-получатель вскоре сгенерирует ответ 
  на пришедший сегмент. Во-вторых, TCP не обязан подтверждать каждый сегмент. 
  В большинстве реализаций при нормальных условиях АСК посылает только на каждый 
  второй сегмент.</p>
<p style='text-align:justify;'><i>Примечание:</i> RFC 1122 [Braden 1989] рекомендует 
  откладывать посылку ACK до 0,5 с при подтверждении каждого второго сегмента.</p>
<p style='text-align:justify;'>Еще одно принципиальное отличие между TCP и UDP 
  в том, что TCP требует логического соединения (совет 1) и, значит, необходимо 
  заботиться об его установлении и разрыве. Для установления соединения обычно 
  требуется обмен тремя сегментами. Для разрыва соединения нужно четыре сегмента, 
  которые, кроме последнего, часто можно скомбинировать с сегментами, содержащими 
  данные.</p>
<p style='text-align:justify;'>Предположим, что время, необходимое для разрыва 
  соединения в большинстве случаев не расходуется зря, поскольку одновременно 
  передаются данные. Следует выяснить, что же происходит во время установления 
  соединения. Как показано на рис. 2.16, клиент начинает процедуру установления 
  соединения, посылая серверу сегмент SYN (синхронизация). В этом сегменте указывается 
  порядковый номер, который клиент присвоит первому посланному байту, а также 
  другие параметры соединения. В частности, максимальный размер сегмента (MSS), 
  который клиент готов принять, и начальный размер окна приема, Сервер в ответ 
  посылает свой сегмент SYN, который также содержит подтверждение АСК на сегмент 
  SYN клиента. И, наконец, клиент отсылает АСК на сегмент SYN сервера. На этом 
  процедура установления соединения завершается. Теперь клиент может послать свой 
  первый сегмент данных.</p>
<p align=center style='text-align:center;'> <img width=239 height=211
src="./img/image019.gif" v:shapes="_x0000_i1026"> </p>
<p align=center style='text-align:center;'>Рис. 2.16. Установление соединения</p>
<p style='text-align:justify;'>На рис. 2.16 RTT (round-trip time) - это период 
  кругового обращения, то есть время, необходимое пакету для прохождения с одного 
  хоста на другой и обратно. Для установления соединения нужно полтора таких периода.</p>
<p style='text-align:justify;'>При длительном соединении между клиентом и сервером 
  (например, клиент и сервер обмениваются большим объемом данных) указанный период 
  «размазывается» между всеми передачами данных, так что существенного влияния 
  на производительность это не оказывает. Однако если речь идет о простой транзакции, 
  в течение которой клиент посылает запрос, получает ответ и разрывает соединение, 
  то время инициализации составляет заметную часть от времени всей транзакции. 
  Таким образом, следует ожидать, что UDP намного превосходит TCP по производительности 
  именно тогда, когда приложение организует короткие сеансы связи. И, наоборот, 
  TСР работает быстрее, когда соединение поддерживается в течении длительного 
  времени при передаче больших объемов данных.</p>
<p style='text-align:justify;'>Чтобы протестировать сравнительную производительность 
  TCP и UDP, а заодно продемонстрировать, как пишутся небольшие тестовые программки, 
  создадим несколько простых серверов и клиентов. Здесь имеется в виду не полнофункциональная 
  контрольная задача, а лишь определение производительности двух протоколов при 
  передаче большого объема данных. Примером такого рода приложения служит протокол 
  FTP.</p>
<h3><a name="p1">Источник и приемник на базе </a>UDP</h3>
<p style='text-align:justify;'>В случае UDP клиент посылает нефиксированное количество 
  датаграмм, которые сервер читает, подсчитывает и отбрасывает. Исходный текст 
  клиента приведен в листинге 2.16.</p>
<p style='text-align:justify'>Листинг 2.16. UDP-клиент, посылающий произвольное 
  число датаграмм</p>
<p style='text-align:justify'><a href="source\udpsource.c">udpsource.с</a></p>
<p style='text-align:justify;'>1    #include   &quot;etcp.h&quot;</p>
<p style='text-align:justify;'>2    int main( int argc, char **argv )</p>
<p style='text-align:justify;'>3    {</p>
<p style='text-align:justify;'>4    struct sockaddr_in peer;</p>
<p style='text-align:justify;'>5    SOCKET s;</p>
<p style='text-align:justify;'>6    int rc;</p>
<p style='text-align:justify;'>7    int datagrams;</p>
<p style='text-align:justify;'>8    int dgramsz = 1440;</p>
<p style='text-align:justify;'>9    char buf[ 1440 ];</p>
<p style='text-align:justify;'>10   INIT();</p>
<p style='text-align:justify;'>11   datagrams = atoi( argv[ 2 ] );</p>
<p style='text-align:justify;'>12   if ( argc &gt; 3 )</p>
<p style='text-align:justify;'>13     dgramsz = atoi( argv [ 3 ] );</p>
<p style='text-align:justify;'>14   s = udp_client( argv[ 1 ], &quot;9000&quot;, 
  &amp;peer );</p>
<p style='text-align:justify;'>15   while ( datagrams-- &gt; 0 )</p>
<p style='text-align:justify;'>16   {</p>
<p style='text-align:justify;'>17     rc = sendto( s, buf, dgramsz, 0,</p>
<p style='text-align:justify;'>18      ( struct sockaddr * )&amp;peer, sizeof( 
  peer ) );</p>
<p style='text-align:justify;'>19     if ( rc &lt;= 0 )</p>
<p style='text-align:justify;'>20      error( 0, errno, &quot;ошибка вызова sendto&quot; 
  );</p>
<p style='text-align:justify;'>21   }</p>
<p style='text-align:justify;'>22   sendto( s, &quot;&quot;, 0, 0,</p>
<p style='text-align:justify;'>23     ( struct sockaddr * )&amp;peer, sizeof( 
  peer ) );</p>
<p style='text-align:justify;'>24   EXIT( 0 );</p>
<p style='text-align:justify;'>25   }</p>
<p style='text-align:justify'>10-14 Читаем из командной строки количество посылаемых 
  датаграмм и их размер (второй параметр необязателен). Подготавливаем в переменной 
  peer UDP-сокет с адресом сервера. Вопреки совету 29 номер порта 9000 жестко 
  «зашит» в код.</p>
<p style='text-align:justify'>15-21 Посылаем указанное количество датаграмм серверу.</p>
<p style='text-align:justify'>22-23 Посылаем серверу последнюю датаграмму, содержащую 
  нулевой байт. Для сервера она выполняет роль конца файла.</p>
<p style='text-align:justify;'>Текст сервера в листинге 2.17 еще проще.</p>
<p style='text-align:justify'>Листинг 2.17. Приемник датаграмм</p>
<p style='text-align:justify'><a href="source\udpsink.c">udpsink.c</a></p>
<p style='text-align:justify;'>1    #include &quot;etcp.h&quot;</p>
<p style='text-align:justify;'>2    int  main( int argc, char **argv   )</p>
<p style='text-align:justify;'>3    {</p>
<p style='text-align:justify;'>4    SOCKET s;</p>
<p style='text-align:justify;'>5    int rc;</p>
<p style='text-align:justify;'>6    int datagrams = 0;</p>
<p style='text-align:justify;'>7    int rcvbufsz = 5000 * 1440;</p>
<p style='text-align:justify;'>8    char buf[ 1440 ];</p>
<p style='text-align:justify;'>9    INIT();</p>
<p style='text-align:justify;'>10   s = udp_server( NULL, &quot;9000&quot; );</p>
<p style='text-align:justify;'>11   setsockopt ( s, SOL_SOCKET, SO_RCVBUF,</p>
<p style='text-align:justify;'>12     ( char * )&amp;rcvbufsz, sizeof( int ) ) 
  ;</p>
<p style='text-align:justify;'>13   for ( ;; )</p>
<p style='text-align:justify;'>14   {</p>
<p style='text-align:justify;'>15     rc = recv( s, buf, sizeof( buf ), 0 );</p>
<p style='text-align:justify;'>16     if ( rc &lt;= 0 )</p>
<p style='text-align:justify;'>17      break;</p>
<p style='text-align:justify;'>18     datagrams++;</p>
<p style='text-align:justify;'>19   }</p>
<p style='text-align:justify;'>20   error( 0, 0, &quot;получено датаграмм: %d 
  \n&quot;, datagrams );</p>
<p style='text-align:justify;'>21   EXIT( 0 ) ;</p>
<p style='text-align:justify;'>22   }</p>
<p style='text-align:justify'>10 Подготавливаем сервер к приему датаграмм из порта 
  9000 с любого интерфейса.</p>
<p style='text-align:justify'>11-12 Выделяем память для буфера на 5000 датаграмм 
  длиной до 1440 байт.</p>
<p style='text-align:justify;'><i>Примечание:</i> Здесь устанавливается размер 
  буфера 7200000 байт, но нет гарантии, что операционная система выделит столько 
  памяти. Хост, работающий под управлением системы BSD, выделил буфер размером 
  41600 байт. Этим объясняется потеря датаграмм, которая будет рассмотрена далее.</p>
<p style='text-align:justify'>13-19 Читаем и подсчитываем датаграммы, пока не 
  придет пустая датаграмма или не произойдет ошибка.</p>
<p style='text-align:justify'>20 Выводим число полученных датаграмм на stdrerr.</p>
<h3><a name="p2">Источник и приемник на базе </a>TCP</h3>
<p style='text-align:justify;'>В совете 32 объясняется, что повысить производительность 
  TCP можно за счет выбора правильного размера буферов передачи и приема. Нужно 
  установить размер буфера приема для сокета сервера и размер буфера передачи 
  для сокета клиента.</p>
<p style='text-align:justify;'>Поскольку в функциях tcp_server и tcp_client используются 
  размеры буферов по умолчанию, следует воспользоваться не библиотекой, а каркасами 
  из совета 4. Сообщать TCP размеры буферов нужно во время инициализации соединения, 
  то есть до вызова listen в сервере и до вызова connect в клиенте. Поэтому невозможно 
  воспользоваться функциями tcp_server и tcp_client, так как к моменту возврата 
  из них обращение к listen или connect уже произошло. Начнем с клиента, его код 
  приведен в листинге 2.18.</p>
<p style='text-align:justify'>Листинг 2.18. Функция main TCP-клиента, играющего 
  роль источника</p>
<p style='text-align:justify'><a href="source\tcpsource.c">tcpsource.с</a></p>
<p style='text-align:justify;'>1    int main ( int argc, char **argv )</p>
<p style='text-align:justify;'>2    {</p>
<p style='text-align:justify;'>3    struct sockaddr_in peer;</p>
<p style='text-align:justify;'>4    char *buf;</p>
<p style='text-align:justify;'>5    SOCKET s;</p>
<p style='text-align:justify;'>6    int с;</p>
<p style='text-align:justify;'>7    int blks = 5000;</p>
<p style='text-align:justify;'>8    int sndbufsz = 32 * 1024;</p>
<p style='text-align:justify;'>9    int sndsz = 1440;  /* MSS для Ethernet по 
  умолчанию. */</p>
<p style='text-align:justify;'>10   INIT();</p>
<p style='text-align:justify;'>11   opterr = 0;</p>
<p style='text-align:justify;'>12   while ( ( с = getopt( argc, argv, &quot;s:b:c:&quot; 
  ) ) != EOF )</p>
<p style='text-align:justify;'>13   {</p>
<p style='text-align:justify;'>14     switch ( с )</p>
<p style='text-align:justify;'>15     {</p>
<p style='text-align:justify;'>16      case &quot;s&quot; :</p>
<p style='text-align:justify;'>17       sndsz = atoi( optarg ) ;</p>
<p style='text-align:justify;'>18       break;</p>
<p style='text-align:justify;'>19      case &quot;b&quot; :</p>
<p style='text-align:justify;'>20       sndbufsz = atoi( optarg ) ;</p>
<p style='text-align:justify;'>21       break;</p>
<p style='text-align:justify;'>22      case &quot;c&quot; :</p>
<p style='text-align:justify;'>23       blks = atoi( optarg );</p>
<p style='text-align:justify;'>2 4      break;</p>
<p style='text-align:justify;'>25      case &quot;?&quot; :</p>
<p style='text-align:justify;'>26       error( 1, 0, &quot;некорректный параметр: 
  %c\n&quot;, с );</p>
<p style='text-align:justify;'>27     }</p>
<p style='text-align:justify;'>28   }</p>
<p style='text-align:justify;'>28   if ( argc &lt;= optind )</p>
<p style='text-align:justify;'>30     error( 1, 0, &quot;не задано имя хоста\n&quot; 
  };</p>
<p style='text-align:justify;'>31   if ( ( buf = malloc( sndsz ) ) == NULL )</p>
<p style='text-align:justify;'>32     error( 1, 0, &quot;ошибка вызова malloc\n&quot; 
  );</p>
<p style='text-align:justify;'>33   set_address( argv[ optind ], &quot;9000&quot;, 
  &amp;peer, &quot;tcp&quot; );</p>
<p style='text-align:justify;'>34   s = socket( AF_INET, SOCK_STREAM, 0 );</p>
<p style='text-align:justify;'>35   if ( !isvalidsock( s ) )</p>
<p style='text-align:justify;'>36     error( 1, errno, &quot;ошибка вызова socket&quot; 
  );</p>
<p style='text-align:justify;'>37   if ( setsockopt( s, SOL_SOCKET, SO_SNDBUF,</p>
<p style='text-align:justify;'>38     ( char * )&amp;sndbufsz, sizeof( sndbufsz 
  ) ) )</p>
<p style='text-align:justify;'>39     error( 1, errno, &quot;ошибка вызова setsockopt 
  с опцией SO_SNDBUF&quot; );</p>
<p style='text-align:justify;'>40   if ( connect( s, ( struct sockaddr * )&amp;peer,</p>
<p style='text-align:justify;'>41     sizeof( peer ) ) )</p>
<p style='text-align:justify;'>42     error( 1, errno, &quot;ошибка вызова connect&quot; 
  );</p>
<p style='text-align:justify;'>43   while( blks-- &gt; 0 )</p>
<p style='text-align:justify;'>44     send( s, buf, sndsz, 0 );</p>
<p style='text-align:justify;'>45   EXIT( 0 );</p>
<p style='text-align:justify;'>46   }</p>
<p style='text-align:justify'>12-30 В цикле вызываем getopt для получения и обработки 
  параметров из командной строки. Поскольку эта программа будет использоваться 
  и далее, то делаем ее конфигурируемой в большей степени, чем необходимо для 
  данной задачи. С помощью параметров в командной строке можно задать размер буфера 
  передачи сокета, количество данных, передаваемых при каждой операции записи 
  в сокет, и число операций записи.</p>
<p style='text-align:justify'>31-42 Это стандартный код инициализации TCP-клиента, 
  только добавлено еще обращение к setsockopt для установки размера буфера передачи, 
  а также с помощью функции malloc выделен буфер запрошенного размера для размещения 
  данных, посылаемых при каждой операции записи. Обратите внимание, что инициализировать 
  память, на которую указывает buf, не надо, так как в данном случае безразлично, 
  какие дан­ные посылать.</p>
<p style='text-align:justify'>43-44 Вызываем функцию send нужное число раз.</p>
<p style='text-align:justify;'>Функция main сервера, показанная в листинге 2.19, 
  взята из стандартного каркаса с добавлением обращения к функции getopt для получения 
  из командной строки параметра, задающего размер буфера приема сокета, а также 
  вызов функ­ции getsockopt для установки размера буфера.</p>
<p style='text-align:justify'>Листинг 2.19. Функция main TCP-сервера, играющего 
  роль приемника</p>
<p style='text-align:justify'><a
href="source\tcpsink.c">tcpsink.с</a></p>
<p style='text-align:justify;'>1    int main( int argc, char **argv )</p>
<p style='text-align:justify;'>2    {</p>
<p style='text-align:justify;'>3    struct sockaddr_in local;</p>
<p style='text-align:justify;'>4    struct sockaddr_in peer;</p>
<p style='text-align:justify;'>5    int peerlen;</p>
<p style='text-align:justify;'>6    SOCKET s1;</p>
<p style='text-align:justify;'>7    SOCKET s;</p>
<p style='text-align:justify;'>8    int c;</p>
<p style='text-align:justify;'>9    int rcvbufsz = 32 * 1024;</p>
<p style='text-align:justify;'>10   const int on = 1;</p>
<p style='text-align:justify;'>11   INIT();</p>
<p style='text-align:justify;'>12   opterr = 0;</p>
<p style='text-align:justify;'>13   while ( ( с = getopt( argc, argv, &quot;b:&quot; 
  ) ) != EOF )</p>
<p style='text-align:justify;'>14   {</p>
<p style='text-align:justify;'>15     switch ( с )</p>
<p style='text-align:justify;'>16     {</p>
<p style='text-align:justify;'>17      case &quot;b&quot; :</p>
<p style='text-align:justify;'>18       rcvbufsz = atoi( optarg };</p>
<p style='text-align:justify;'>19       break;</p>
<p style='text-align:justify;'>20      case &quot;.?&quot; :</p>
<p style='text-align:justify;'>21       error( 1, 0, &quot;недопустимая опция: 
  %c\n&quot;, с );</p>
<p style='text-align:justify;'>22     }</p>
<p style='text-align:justify;'>23   }</p>
<p style='text-align:justify;'>24   set_address( NULL, &quot;9000&quot;, &amp;local, 
  &quot;tcp&quot; );</p>
<p style='text-align:justify;'>25   s = socket( AF_INET, SOCK_STREAM, 0 );</p>
<p style='text-align:justify;'>26   if ( !isvalidsock( s ) )</p>
<p style='text-align:justify;'>27     error( 1, errno, &quot;ошибка вызова socket&quot; 
  ) ;</p>
<p style='text-align:justify;'>28   if ( setsockopt( s, SOL_SOCKET, SO_REUSEADDR,</p>
<p style='text-align:justify;'>29     ( char * )&amp;on, sizeof( on ) ) )</p>
<p style='text-align:justify;'>30     error( 1, errno, &quot;ошибка вызова setsockopt 
  SO_REUSEADDR&quot;)</p>
<p style='text-align:justify;'>31   if ( setsockopt( s, SOL_SOCKET, SO_RCVBUF,</p>
<p style='text-align:justify;'>32     ( char * )&amp;rcvbufsz, sizeof( rcvbufsz 
  ) ) )</p>
<p style='text-align:justify;'>33     error( 1, errno, &quot;ошибка вызова setsockopt 
  SO_RCVBUF&quot;)</p>
<p style='text-align:justify;'>34   if ( bind( s, ( struct sockaddr * ) &amp;local,</p>
<p style='text-align:justify;'>35     sizeof( local ) ) )</p>
<p style='text-align:justify;'>36.    error ( 1, errno, &quot;ошибка вызова bind&quot; 
  ) ;</p>
<p style='text-align:justify;'>37   listen( s, 5 );</p>
<p style='text-align:justify;'>38   do</p>
<p style='text-align:justify;'>39   {</p>
<p style='text-align:justify;'>40     peerlen = sizeof( peer );</p>
<p style='text-align:justify;'>41     s1 = accept( s, ( struct sockaddr *)&amp;peer, 
  &amp;peerlen );</p>
<p style='text-align:justify;'>42     if ( !isvalidsock( s1 ) )</p>
<p style='text-align:justify;'>43      error( 1, errno, &quot;ошибка вызова accept&quot; 
  );</p>
<p style='text-align:justify;'>44     server( s1, rcvbufsz );</p>
<p style='text-align:justify;'>45     CLOSE( s1 );</p>
<p style='text-align:justify;'>46   } while ( 0 );</p>
<p style='text-align:justify;'>47   EXIT( 0 );</p>
<p style='text-align:justify;'>48   }</p>
<p style='text-align:justify;'>Функция server читает и подсчитывает поступающие 
  байты, пока не обнаружит конец файла (совет 16) или не возникнет ошибка. Она 
  выделяет память под буфер того же размера, что и буфер приема сокета, чтобы 
  прочитать максимальное количество данных за одно обращение к recv. Текст функции 
  server приведен в листинге 2.20.</p>
<p style='text-align:justify;'>Листинг 2.20. Функция server</p>
<p style='text-align:justify;'><a href="source\tcpsink.c">tcpsink.c</a> </p>
<p style='text-align:justify;'>1    static void server(   SOCKET  s, int rcvbufsz 
  )</p>
<p style='text-align:justify;'>2    {</p>
<p style='text-align:justify;'>3    char  *buf;</p>
<p style='text-align:justify;'>4    int rc;</p>
<p style='text-align:justify;'>5    int bytes =0;</p>
<p style='text-align:justify;'>6    if ( ( buf   =  malloc( rcvbufsz ) ) == NULL 
  )</p>
<p style='text-align:justify;'>7      error( 1, 0, &quot;ошибка  вызова malloc\n&quot;};</p>
<p style='text-align:justify;'>8    for ( ; ;  )</p>
<p style='text-align:justify;'>9    {</p>
<p style='text-align:justify;'>10     rc = recv( s, buf, rcvbufsz, 0 );</p>
<p style='text-align:justify;'>11     if ( rc &lt;= 0 )</p>
<p style='text-align:justify;'>12      break;</p>
<p style='text-align:justify;'>13     bytes += rc;</p>
<p style='text-align:justify;'>14   }</p>
<p style='text-align:justify;'>15   error( 0, 0, &quot;получено байт: %d\n&quot;, 
  bytes );</p>
<p style='text-align:justify;'>16   }</p>
<p style='text-align:justify;'>Для измерения сравнительной производительности 
  протоколов TCP и UDP при передаче больших объемов данных запустим клиента на 
  машине bsd, а сервер&nbsp;- на localhost. Физически хосты bsd localhost&nbsp;- 
  это, конечно, одно и то же, но, как вы увидите, результаты работы программы 
  в значительной степени зависят от того, какое из этих имен использовано. Сначала 
  запустим клиента и сервер на одной машине, чтобы оценить производительность 
  TCP и UDP, устранив влияние сети. В обоих случаях сегменты TCP или датаграммы 
  UDP инкапсулируются в IP-датаграммах и посылаются возвратному интерфейсу 1оО, 
  который немедленно переправляет их процедуре обработки IP-входа, как показано 
  на рис. 2.17.</p>
<p align=center style='text-align:center;'> <img border=0 width=294 height=298
src="./img/image020.gif" v:shapes="_x0000_i1025"> </p>
<p align=center style='text-align:center;'>Рис. 2.17. Возвратный интерфейс</p>
<p style='text-align:justify;'>Каждый тест был выполнен 50 раз с заданным размером 
  датаграмм (в случае UDP) или числом передаваемых за один раз байтов (в случае 
  TCP), равным 1440. Эта величина выбрана потому, что она близка к максимальному 
  размеру сегмента, который TCP может передать по локальной сети на базе Ethernet.</p>
<p style='text-align:justify;'><i>Примечание:</i> Это число получается так. В 
  одном фрейме Ethernet может быть передано не более 1500 байт. Каждый заголовок 
  IP и TCP занимает 20 байт, так что остается 1460. Еще 20 байт резервировано 
  для опций TCP. В системе BSD TCP посылает 12 байт с опциями, поэтому в этом 
  случае максимальный размер сегмента составляет 1448 байт.</p>
<p style='text-align:justify;'>В табл. 2.2 приведены результаты, усредненные по 
  50 прогонам. Для каждого протокола указано три времени: по часам - время с момента 
  запуска до завершения работы клиента; пользовательское - проведенное программой 
  в режиме пользователя; системное - проведенное программой в режиме ядра. В колонке 
  «Мб/с» указан результат деления общего числа посланных байтов на время по часам. 
  В колонке «Потеряно» для UDP приведено среднее число потерянных датаграмм.</p>
<p style='text-align:justify;'>Первое, что бросается в глаза, - TCP работает намного 
  быстрее, когда в качестве имени сервера выбрано localhost, а не bsd. Для UDP 
  это не так – заметной разницы в производительности нет. Чтобы понять, почему 
  производительность TCР так возрастает, когда клиент отправляет данные хосту 
  localhost, запустим программу netstat (совет 38) с опцией&nbsp;-i. Здесь надо 
  обратить внимание на две строки (ненужная информация опущена):</p>
<p style='text-align:justify;'>Name    Mtu         Network    Address</p>
<p style='text-align:justify;'>Ed0    1500       172.30       bsd</p>
<p style='text-align:justify;'>lo0      16384    127              localhost</p>
<p style='text-align:justify'>Таблица 2.2. Сравнение производительности TCP и 
  UDP при количестве посылаемых байтов, равном 1440</p>
<table border=1 cellspacing=0 cellpadding=0>
  <tr> 
    <td width=638 colspan=7 valign=top class="Normal"> 
      <p align=center style='text-align:center'>TCP</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>Сервер</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>Время&nbsp;по часам</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>Пользовательское время</p>
    </td>
    <td width=124 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>Системное время</p>
    </td>
    <td width=136 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>Мб/с</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>bsd</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>2,88</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>0,0292</p>
    </td>
    <td width=124 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>1,4198</p>
    </td>
    <td width=136 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>2,5</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>localhost</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>0,9558</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>0,0096</p>
    </td>
    <td width=124 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>0,6316</p>
    </td>
    <td width=136 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>7,53</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>sparс</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>7,1882</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>0,016</p>
    </td>
    <td width=124 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>1,6226</p>
    </td>
    <td width=136 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>1,002</p>
    </td>
  </tr>
  <tr> 
    <td width=638 colspan=7 valign=top class="Normal"> 
      <p align=center style='text-align:center'>UDP</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>Сервер</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>Время&nbsp;по часам</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>Пользовательское время</p>
    </td>
    <td width=109 valign=top class="Normal"> 
      <p style='text-align:justify'>Системное время</p>
    </td>
    <td width=60 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>Мб/с</p>
    </td>
    <td width=91 valign=top class="Normal"> 
      <p style='text-align:justify'>Потеряно</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>bsd</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>1,9618</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>0,0316</p>
    </td>
    <td width=109 valign=top class="Normal"> 
      <p style='text-align:justify'>1,1934</p>
    </td>
    <td width=60 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>3,67</p>
    </td>
    <td width=91 valign=top class="Normal"> 
      <p style='text-align:justify'>336</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>localhost</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>1,9748</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>0,031</p>
    </td>
    <td width=109 valign=top class="Normal"> 
      <p style='text-align:justify'>1,1906</p>
    </td>
    <td width=60 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>3,646</p>
    </td>
    <td width=91 valign=top class="Normal"> 
      <p style='text-align:justify'>272</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>sparс</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>5,8284</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>0,0564</p>
    </td>
    <td width=109 valign=top class="Normal"> 
      <p style='text-align:justify'>0,844</p>
    </td>
    <td width=60 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>1,235</p>
    </td>
    <td width=91 valign=top class="Normal"> 
      <p style='text-align:justify'>440</p>
    </td>
  </tr>
  <tr height=0> 
    <td width=121 class="Normal"></td>
    <td width=119 class="Normal"></td>
    <td width=138 class="Normal"></td>
    <td width=109 class="Normal"></td>
    <td width=15 class="Normal"></td>
    <td width=45 class="Normal"></td>
    <td width=91 class="Normal"></td>
  </tr>
</table>
<p style='text-align:justify;'>Как видите, максимальный размер передаваемого блока 
  (MTU - maximum transmission unit) для bsd равен 1500, а для localhost - 16384.</p>
<p style='text-align:justify;'><i>Примечание:</i> Такое поведение свойственно 
  реализациям TCP в системах, производных от BSD. Например, в системе Solaris 
  это уже не так. При первом построении маршрута к хосту bsd в коде маршрутизации 
  предполагается, что хост находится в локальной сети, поскольку сетевая часть 
  IP-адреса совпадает с адресом интерфейса Ethernet. И лишь при первом использовании 
  маршрута TCP обнаруживает, что он ведет на тот же хост и переключается на возвратный 
  интерфейс. Однако к этому моменту все метрики маршрута, в том числе и MTU, уже 
  установлены в соответствии с интерфейсом к локальной сети.</p>
<p style='text-align:justify;'>Это означает, что при посылке данных на localhost 
  TCP может отправлять сегменты длиной до 16384 байт (или 16384 - 20 - 20 - 12 
  - 16332 байт). Однако при посылке данных на хост bsd число байт в сегменте не 
  превышает 1448 (как было сказано выше). Но чем больше размер сегментов, тем 
  меньшее их количество приходится посылать, а это значит, что требуется меньший 
  объем обработки, и соответственно снижаются накладные расходы на добавление 
  к каждому сегменту заголовков IP и TCP. А результат налицо - обмен данными с 
  хостом localhost происходит в три раза быстрее, чем с хостом bsd.</p>
<p style='text-align:justify;'>Можно заметить, что на хосте localhost TCP работает 
  примерно в два раза быстрее, чем UDP. Это также связано с тем, что TCP способен 
  объединять несколько блоков по 1440 байт в один сегмент, тогда как UDP посылает 
  отдельно каждую датаграмму длиной 1440 байт.</p>
<p style='text-align:justify;'>Следует отметить, что в локальной сети UDP примерно 
  на 20% быстрее TCP, потеря датаграмм значительнее. Потери имеют место даже тогда, 
  когда и сервер и клиент работают на одной машине; связаны они с исчерпанием 
  буферов. Хотя передача 5000 датаграмм на максимально возможной скорости - это 
  скорее отклонение, чем нормальный режим работы, но все же следует иметь в виду 
  возможность такого результата. Это означает, что UDP не дает никакой гарантии 
  относительно доставки данной датаграммы, даже если оба приложения работают на 
  одной машине.</p>
<p style='text-align:justify;'>По результатам сравнения сеансов с хостами localhost 
  и bsd можно предположить, что на производительность влияет также длина посылаемых 
  датаграмм. Например, если прогнать те же тесты с блоком длиной 300 байт, то, 
  как следует из табл. 2.3, TCP работает быстрее UDP и на одной машине, и в локальной 
  сети.</p>
<p style='text-align:justify;'>Из этих примеров следует важный вывод: нельзя строить 
  априорные предположения о сравнительной производительности TCP и UDP. При изменении 
  условий, даже очень незначительном, показатели производительности могут очень 
  резко измениться. Для обоснованного выбора протокола лучше сравнить их производительность 
  на контрольной задаче (совет 8). Когда это неосуществимо на практике, все же 
  можно написать небольшие тестовые программы для получения хотя бы приблизительного 
  представления о том, чего можно ожидать,</p>
<p style='text-align:justify'>Таблица. 2.3. Сравнение производительности TCP и 
  UDP при количестве посылаемых байтов, равном 300</p>
<table border=1 cellspacing=0 cellpadding=0>
  <tr> 
    <td width=638 colspan=7 valign=top class="Normal"> 
      <p align=center style='text-align:center'>TCP</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>Сервер</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>Время&nbsp;по часам</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>Пользовательское время</p>
    </td>
    <td width=124 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>Системное время</p>
    </td>
    <td width=136 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>Мб/с</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>bsd</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>1,059</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>0,0124</p>
    </td>
    <td width=124 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>0,445</p>
    </td>
    <td width=136 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>1,416</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>sparс</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>1,5552</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>0,0084</p>
    </td>
    <td width=124 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>1,2442</p>
    </td>
    <td width=136 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>0,965</p>
    </td>
  </tr>
  <tr> 
    <td width=638 colspan=7 valign=top class="Normal"> 
      <p align=center style='text-align:center'>UDP</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>Сервер</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>Время&nbsp;по часам</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>Пользовательское время</p>
    </td>
    <td width=109 valign=top class="Normal"> 
      <p style='text-align:justify'>Системное время</p>
    </td>
    <td width=60 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>Мб/с</p>
    </td>
    <td width=91 valign=top class="Normal"> 
      <p style='text-align:justify'>Потеряно</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>bsd</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>1,6324</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>0,0324</p>
    </td>
    <td width=109 valign=top class="Normal"> 
      <p style='text-align:justify'>0,9998</p>
    </td>
    <td width=60 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>0,919</p>
    </td>
    <td width=91 valign=top class="Normal"> 
      <p style='text-align:justify'>212</p>
    </td>
  </tr>
  <tr> 
    <td width=121 valign=top class="Normal"> 
      <p style='text-align:justify'>sparс</p>
    </td>
    <td width=119 valign=top class="Normal"> 
      <p style='text-align:justify'>1,9118</p>
    </td>
    <td width=138 valign=top class="Normal"> 
      <p style='text-align:justify'>0,0278</p>
    </td>
    <td width=109 valign=top class="Normal"> 
      <p style='text-align:justify'>1,4352</p>
    </td>
    <td width=60 colspan=2 valign=top class="Normal"> 
      <p style='text-align:justify'>0,785</p>
    </td>
    <td width=91 valign=top class="Normal"> 
      <p style='text-align:justify'>306</p>
    </td>
  </tr>
  <tr height=0> 
    <td width=121 class="Normal"></td>
    <td width=119 class="Normal"></td>
    <td width=138 class="Normal"></td>
    <td width=109 class="Normal"></td>
    <td width=15 class="Normal"></td>
    <td width=45 class="Normal"></td>
    <td width=91 class="Normal"></td>
  </tr>
</table>
<p style='text-align:justify;'>Если говорить о практической стороне вопроса, то 
  современные реализации статочно эффективны. Реально продемонстрировано, что 
  TCP может работать со скоростью аппаратуры на стомегабитных сетях FDDI. В недавних 
  экспериментах были достигнуты почти гигабитные скорости при работе на персональном 
  компьютере [Gallatin et al. 1999].</p>
<p style='text-align:justify;'><i>Примечение:</i> 29 июля 1999 года исследователи 
  из Университета Дъюка на рабочей станции ХР1000 производства DEC/Compaq на базе 
  процессора Alpha в сети Myrinet получили скорости передачи порядка гигабита 
  в секунду. В экспериментах использовался стандартный стек TCP/IP из системы 
  FreeBSD 4.0, модифицированный по технологии сокетов без копирования (zero-copy 
  sockets). В том же эксперименте была получена скорость более 800 Мбит/с на персональном 
  компьютере PII 450 МГц и более ранней версии сети Myrinet. Подробности можно 
  прочитать на Web-странице http://www.cs.duke.edu/ari/trapeze.</p>
<h3><a name="p3">Резюме</a></h3>
<p style='text-align:justify;'>UDP не всегда быстрее, чем TCP. На сравнительную 
  производительность обоих протоколов влияют разные факторы, и для каждого конкретного 
  случая желательно проверять быстродействие на контрольных задачах.</p>
<hr><div align="right"><a href="adv7.htm#top">Вверх</a> | <a href="index.htm">Содержание</a> | <a href="adv6.htm">Назад</a> | <a href="adv8.htm">Далее</a></div>
</body>
</html>
