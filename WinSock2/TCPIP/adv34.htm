<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<link href="style.css" type="text/css" rel=stylesheet>
<title>Совет 34</title>
</head>
<body lang=RU link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">
<h2><a name="top">Совет 34. Используйте программу </a>tcpdump или аналогичное 
  средство</h2>
<hr><div align="right"><a href="adv34.htm#p4">Вниз</a> | <a href="index.htm">Содержание</a> | <a href="adv33.htm">Назад</a> | <a href="adv35.htm">Далее</a></div>
<p style='text-align:justify;'>Из всех имеющихся в нашем распоряжении мощных и 
  полезных средств отладки сетевых приложений и поиска неисправностей в сети наиболее 
  интересны сетевые анализаторы (их еще называют сниферами). Традиционно сетевой 
  анализатор - дорогое специализированное устройство, но современные рабочие станции 
  вполне способны выполнять их функции в рамках отдельного процесса.</p>
<p style='text-align:justify;'>Сегодня сниферы есть для большинства сетевых операционных 
  систем. Иногда в операционную систему входит снифер, предлагаемый поставщиком 
  (программа snoop в Solaris или программы iptrace/ipreport в AIX), а иногда пользуются 
  программами третьих фирм, например tcpdump.</p>
<p style='text-align:justify;'>Из инструментов, предназначенных только для диагностики, 
  сниферы постепенно превратились в средства для исследований и обучения. Например, 
  они постоянно используются для изучения динамики и взаимодействий в сетях. В 
  книгах [Stevens 1994, Stevens 1996] рассказано, как использовать tcpdump, чтобы 
  разобраться в работе сетевых протоколов. Наблюдая за данными, которые посылает 
  протокол, вы можете глубже понять его функционирование на практике, а заодно 
  увидеть, когда некоторая конкретная реализация работает не в соответствии со 
  спецификацией.</p>
<p style='text-align:justify;'>В этом разделе будет рассмотрена утилита tcpdump. 
  Как уже отмечалось, есть и другие программно реализованные сетевые анализаторы. 
  Некоторые из них лучше форматируют выходные данные, но у tcpdump есть одно неоспоримое 
  преимущество - она работает практически во всех UNIX-системах и в Windows. Поскольку 
  исходные тексты tcpdump опубликованы, ее можно при необходимости адаптировать 
  для специальных целей или перенести на новую платформу.</p>
<p style='text-align:justify;'>Код tcpdump вы можете найти на сайте http://www-nrg.ee.lbl.gov/nrg.html, 
  а исходные тексты и исполняемый код для Windows WinDump&nbsp;- http://netgroup-serv.polito.it/windump.</p>
<h3><a name="p1">Как работает </a>tcpdump</h3>
<p style='text-align:justify;'>Посмотрим, как работает программа t cpdump и на 
  каком уровне протоколов она перехватывает пакеты. Как и большинство сетевых 
  анализаторов, tcpdump состоит из двух компонент: первая работает в ядре и занимается 
  перехватом и, возможно фильтрацией пакетов, а вторая действует в адресном пространстве 
  пользователя и определяет интерфейс пользователя, а также выполняет форматирование 
  и фильтрацию пакетов, если последнее не делается ядром.</p>
<p style='text-align:justify;'>Пользовательская компонента tcpdump взаимодействует 
  с компонентой в ядре при помощи библиотеки libpcap (библиотека для перехвата 
  пакетов), которая абстрагирует системно-зависимые детали общения с канальным 
  уровнем стека протоколов. Например, в системах на основе BSD libpcap взаимодействует 
  с пакетным фильтром BSD (BSD packet filter - BPF) [McCanne and Jacobson 1993]. 
  BPF исследует каждый пакет, проходящий через канальный уровень, и сопоставляет 
  его с фильтром, заданным пользователем. Если пакет удовлетворяет критерию фильтрации, 
  то его копия помещается в выделенный ядром буфер, который ассоциируется с данным 
  фильтром. Когда буфер заполняется или истекает заданный пользователем тайм-аут, 
  содержимое буфера передается приложению с помощью libpcap.</p>
<p style='text-align:justify;'>Этот процесс изображен на рис. 4.4. Показано, как 
  tcpdump и любая другая программа считывают необработанные пакеты с помощью BPF, 
  а также изображено еще одно приложение, читающее данные из стека TCP/IP, как 
  обычно.</p>
<p style='text-align:justify;'><i>Примечание:</i> Хотя на этом рисунке и tcpdump, 
  и программа используют библиотеку libpcap, можно напрямую общаться с ВРF или 
  иным интерфейсом, о чем будет сказано ниже. Достоинство libpcap в том, что она 
  предоставляет системно-независимые средства доступа к необработанным пакетам. 
  В настоящее время эта библиотека поддерживает BPF; интерфейс канального провайдера 
  (data link provider interface – DLPI); систему SunOS NIT; потоковую NIT; сокеты 
  типа SOCK_PACKET, применяемые в системе Linux; интерфейс snoop (IRIX) и разработанный 
  в Стэнфордском университете интерфейс enet. В дистрибутив WinDump входит также 
  версия libpcap для Windows.</p>
<p style='text-align:justify;'>Обратите внимание, что BPF перехватывает сетевые 
  пакеты на уровне драйвера устройства, то есть сразу после того, как они считаны 
  с носителя. Это не то же самое что чтение из простого сокета. В ситуации с простым 
  сокетом вы получаете IР-датаграммы, уже обработанные уровнем IP и переданные 
  непосредственно приложению минуя транспортный уровень (TCP или UDP). Об этом 
  рассказывается в совете 40.</p>
<p style='text-align:justify;'>Начиная с версии 2.0, архитектура WinDump очень 
  напоминает используемую в системах BSD. Эта программа пользуется специальным 
  NDIS-драйвером (NDIS- Network Driver Interface Specification - спецификация 
  стандартного интерфейса сетевых адаптеров), предоставляющим совместимый с BPF 
  фильтр и интерфейс. В архитектуре WinDump NDIS-драйвер фактически представляет 
  собой часть стека протоколов, но функционирует он так же, как показано на рис. 
  4.4, только надо заменить BPF на пакетный драйвер NDIS.</p>
<p align=center style='text-align:center;'> <img width=468 height=420
src="./img/image043.gif" v:shapes="_x0000_i1025"> </p>
<p align=center style='text-align:center;'>Рис. 4.4. Перехват пакетов с помощью 
  BPF</p>
<p style='text-align:justify;'>Другие операционные системы используют несколько 
  иные механизмы. В системах, производных от SVR4, для доступа к простым сокетам 
  применяется интерфейс DLPI [Unix International 1991]. DLPI - это не зависящий 
  от протокола, основанный на системе STREAMS [Ritchie 1984] интерфейс к канальному 
  уровню, С помощью DLPI можно напрямую получить доступ к канальному уровню, но 
  по соображениям эффективности обычно вставляют в поток STREAMS-модули pfmod 
  и bufmod. Модуль bufmod предоставляет услуги по буферизации сообщений и увеличивает 
  эффективность за счет ограничения числа контекстных переключений, требуемых 
  для доставки данных.</p>
<p style='text-align:justify;'><i>Примечание:</i> Это аналогично чтению полного 
  буфера из сокета вместо побайтного чтения.</p>
<p style='text-align:justify;'>Модуль pfmod - это фильтр, аналогичный BPF. Поскольку 
  он несовместим с фильтром BPF, tcpdump вставляет этот модуль в поток, а фильтрацию 
  выполняет в пространстве пользователя. Это не столь эффективно, как при использовании 
  BPF, так как в пространство пользователя приходится передавать каждый пакет, 
  даже если он не нужен программе tcpdump.</p>
<p style='text-align:justify;'>На рис. 4.5 показаны tcpdump без модуля pf mod 
  и приложение, которое получает необработанные пакеты с использованием находящегося 
  в ядре фильтра.</p>
<p style='text-align:justify;'>На рис. 4.5 также представлены приложения, пользующиеся 
  библиотекой libpcap, но, как и в случае BPF, это необязательно. Для отправки 
  сообщений непосредственно в поток и получения их обратно можно было бы воспользоваться 
  вызовами getmsg и putmsg. Книга [Rago 1993] - отличный источник информации о 
  программировании системы STREAMS, DLPI и системных вызовах getmsg и putmsq. 
  Более краткое обсуждение вопроса можно найти в главе 33 книги [Stevens 1998].</p>
<p align=center style='text-align:center;'> <img width=445 height=415
src="./img/image044.gif" v:shapes="_x0000_i1026"> </p>
<p align=center style='text-align:center;'>Рис. 4.5. Перехват пакетов с помощью 
  DLPI</p>
<p style='text-align:justify;'>Наконец, есть еще и архитектура Linux. В этой системе 
  доступ к необработанным сетевым пакетам производится через интерфейс сокетов 
  типа SOCK_PACKET. Для использования этого простого механизма надо открыть подобный 
  сокет, привязать к нему требуемый сетевой интерфейс, включить режим пропускания 
  всех пакетов (promiscuous mode) и читать из сокета.</p>
<p style='text-align:justify;'><i>Примечание:</i> Начиная с версии 2.2 ядра Linux, 
  рекомендуется несколько другой интерфейс, но последняя версия libpcap по-прежнему 
  поддерживает описанный выше.</p>
<p style='text-align:justify;'>Например, строка</p>
<p style='text-align:justify'>s = socket( AF_INET, SOCK_PACKET, htons( ETH_P_ALL 
  ) );</p>
<p style='text-align:justify'>открывает сокет, предоставляющий доступ ко всем 
  Ethernet-пакетам. В качестве третьего параметра можно также указать ЕТН_Р_IР 
  (пакеты IP), ETH_P_IPV6 (пакеты IPv6) или ETH_P_ARP (пакеты ARP). Будем считать, 
  что этот интерфейс аналогичен простым сокетам (SOCK_RAW), только доступ производится 
  к канальному, а не сетевому (IP) уровню.</p>
<p style='text-align:justify;'>К сожалению, несмотря на простоту и удобство этого 
  интерфейса, он не очень эффективен. В отличие от обычных сокетов, ядро в этом 
  случае не осуществляет никакой буферизации, так что каждый пакет доставляется 
  приложением сразу после поступления. Отсутствует также фильтрация на уровне 
  ядра (если не считать параметра ЕТН_Р_* ). Поэтому фильтровать приходится на 
  прикладном уровне, а это означает, что приложение должно получать все пакеты 
  без исключения.</p>
<h3><a name="p2">Использование</a> tcpdump</h3>
<p style='text-align:justify;'>Прежде всего для использования tcpdump надо получить 
  разрешение. Поскольку применение сетевых анализаторов небезопасно, по умолчанию 
  tcpdump конфигурируется с полномочиями суперпользователя root.</p>
<p style='text-align:justify;'><i>Примечание:</i> К системе Windows это не относится. 
  Коль скоро NDIS-драйвер для перехвата пакетов установлен, воспользоваться программой 
  WinDump может любой.</p>
<p style='text-align:justify;'>Во многих случаях лучше дать возможность всем пользователям 
  работать с программой tcpdump, не передавая им полномочия суперпользователя. 
  Это делается по-разному, в зависимости от версии UNIX и документировано в руководстве 
  по tcpdump. В большинстве случаев надо либо предоставить всем права на чтение 
  из сетевого интерфейса, либо сделать tcpdump setuid-программой.</p>
<p style='text-align:justify;'>Проще всего вызвать tcpdump вообще без параметров. 
  Тогда она будет перехватывать все сетевые пакеты и выводить о них информацию. 
  Однако полезнее, указать какой-нибудь фильтр, чтобы видеть только нужные пакеты 
  и не отвлекаться на остальные. Например, если требуются лишь пакеты, полученные 
  от хоста bsd или отправленные ему, то можно вызвать tcpdump так:</p>
<p style='text-align:justify'>tcpdump host bsd</p>
<p style='text-align:justify;'>Если же нужны пакеты, которыми обмениваются хосты 
  bsd и sparc, то можно использовать такой фильтр:</p>
<p style='text-align:justify'>host bsd and host spare</p>
<p style='text-align:justify'>или сокращенно -</p>
<p style='text-align:justify'>host bsd and spare</p>
<p style='text-align:justify;'>Язык для задания фильтров достаточно богат и позволяет 
  фильтровать, например, по следующим атрибутам:</p>
<ul type=disc>
  <li style='text-align:justify;     '>протокол;</li>
  <li style='text-align:justify;     '>хост отправления и/или назначения;</li>
  <li style='text-align:justify;     '>сеть отправления и/или назначения;</li>
  <li style='text-align:justify;     '>Ethernet-адрес отправления и/или назначения;</li>
  <li style='text-align:justify;     '>порт отправления и/или назначения;</li>
  <li style='text-align:justify;     '>размер пакета;</li>
  <li style='text-align:justify;     '>пакеты, вещаемые на всю локальную сеть 
    или на группу (как в Ethernet так, и в IP);</li>
  <li style='text-align:justify;     '>пакет, используемый в качестве шлюза указанным 
    хостом.</li>
</ul>
<p style='text-align:justify;'>Кроме того, можно проверять конкретные биты или 
  байты в заголовках протоколов. Например, чтобы отбирать только TCP-сегменты, 
  в которых выставлен бит срочных данных, следует использовать фильтр</p>
<p style='text-align:justify'>tcp[ 13 ] &amp; 16</p>
<p style='text-align:justify;'>Чтобы понять последний пример, надо знать, что 
  четвертый бит четырнадцатого байта заголовка TCP - это бит срочности.</p>
<p style='text-align:justify;'>Поскольку разрешается использовать булевские операторы 
  and (или &amp;&amp;), or (или&nbsp;|| ) и not (или !) для комбинирования простых 
  предикатов, можно задавать фильтры произвольной сложности. Ниже приведен пример 
  фильтра, отбирающего ICMP-пакеты, приходящие из внешней сети:</p>
<p style='text-align:justify'>icmp and not  src net  localnet</p>
<p style='text-align:justify;'>Примеры более сложных фильтров рассматриваются 
  в документации по tcpdump.</p>
<h3><a name="p3">Выходная информация, формируемая </a>tcpdump</h3>
<p style='text-align:justify;'>Информация, выдаваемая программой tcpdump, зависит 
  от протокола. Рассмотрим несколько примеров, которые помогут составить представление 
  о том, что можно получить от tcpdump для наиболее распространенных протоколов. 
  Документация, поставляемая вместе с программой, содержит исчерпывающие сведения 
  о формате выдачи.</p>
<p style='text-align:justify;'>Первый пример - это трассировка сеанса по протоколу 
  SMTP (Simple Mail Transfer Protocol - простой протокол электронной почты), то 
  есть процедура отправки элек­тронного письма. Распечатка на рис. 4.6 в точности 
  соответствует выдаче tcpdump, только добавлены номера строк, напечатанные курсивом, 
  удалено имя домена хоста bsd и перенесены длинные строки, не уместившиеся на 
  странице.</p>
<p style='text-align:justify;'>Для получения трассировки послано письмо пользователю 
  с адресом в домен gte.&nbsp;net. Таким образом, адрес имел вид user@gte.net.</p>
<p style='text-align:justify;'>Строки 1-4 относятся к поиску адреса SMTP-сервера, 
  обслуживающего домен gte.&nbsp;net. Это пример выдачи, генерируемой tcpdump 
  для запросов и ответов сервиса DNS. В строке 1 bsd запрашивает у сервера имен 
  своего сервис-провайдера (nsl. ix.netcom.com) имя или имена почтового сервера 
  gte.net. В первом находится временной штамп пакета (12:54:32.920881). Поскольку 
  разрешающая способность таймера на машине bsd составляет 1 мкс, показано шесть 
  десятичных знаков. Вы видите, что пакет ушел из порта 1067 на bsd в порт 53 
  (domain) на машине nsl. Далее, дается информация о данных в пакете. Первое поле 
  (45801)&nbsp;-</p>
<p>1  12:54:32.920881 bsd.1067 &gt; nsl.ix.netcom.com.domain:</p>
<p> 45801+ MX? gte.net. (25)</p>
<p>2  12:54:33.254981 nsl.ix.netcom.com.domain &gt; bsd.1067:</p>
<p>      45801 5/4/9 (371) (DF)</p>
<p>3  12:54:33.256127 bsd.1068 &gt; nsl.ix.netcom.com.domain:</p>
<p>      45802+ A? mtapop2.gte.net. (33)</p>
<p>4  12:54:33.534962 nsl.ix.netcom.com.domain &gt; bsd.1068:</p>
<p>      45802 1/4/4 (202) (DF)</p>
<p>5  12:54:33.535737 bsd.1059 &gt; mtapop2.gte.net.smtp:</p>
<p> S 585494507:585494507(0) win 16384</p>
<p>      &lt;mss 1460,nop,wscale 0,nop,nop,</p>
<p>      timestamp 6112 0&gt; (DF)</p>
<p>6  12:54:33.784963 mtapop2.gte.net.smtp &gt; bsd.1059:</p>
<p>      S1257159392:1257159392(0) ack 585494509 win 49152</p>
<p>      &lt;mss 1460,nop,wscale 0,nop,nop,</p>
<p>      timestamp 7853753 6112&gt; (DF)</p>
<p>7  12:54:33.785012 bsd.1059 &gt; mtapop2.gte.net.smtp:</p>
<p>      .ack 1 win 17376 &lt;nop,nop,</p>
<p>      timestamp 6112 7853753&gt; (DF)</p>
<p>8  12:54:34.235066 mtapop2.gte.net.smtp &gt; bsd.1059:</p>
<p>      P 1:109(108) ack 1 win 49152</p>
<p>      &lt;nop,nop,timestamp 7853754 6112&gt; (DF)</p>
<p>9  12:54:34.235277 bsd.1059 &gt; mtapop2.gte.net.smtp:</p>
<p>      P 1:19(10) ack 109 win 17376</p>
<p>      &lt;nop,nop,timestamp 6113 7853754&gt; (DF)</p>
<p>      14 строк опущено</p>
<p>24 12:54:36.675105 bsd.1059 &gt; mtapop2.gte.net.smtp:</p>
<p>      F 663:663(0) ack 486 3win 17376</p>
<p>      &lt;nop,nop,timestamp 6118 7853758&gt; (DF)    </p>
<p>25 12:54:36.685080 mtapop2.gte.net.smtp &gt; bsd.1059:</p>
<p>      F 486:486(0) ack 663 win 49152</p>
<p>      &lt;nop,nop,timestamp 7853758 6117&gt; (DF)</p>
<p>26 12:54:36.685126 bsd.1059 &gt; mtapop2.gte.net.smtp:</p>
<p>      . ack 487 win 17376</p>
<p>      &lt;nop,nop,timestamp 6118 7853758&gt; (DF)</p>
<p>27 12:54:36.934985 mtapop2.gte3.net.smtp &gt; bsd.1059:</p>
<p>      F 486:486(0) ack 664 win 49152</p>
<p>      &lt;nop,nop,timestamp 7853759 6118&gt; (DF)</p>
<p>28 12:54:36.935020 bsd.1059 &gt; mtapop2.gte.net.smtp:</p>
<p>      . ack 487 win 17376</p>
<p>      &lt;nop,nop,timestamp 6118 7853759&gt; (DF)</p>
<p align=center style='text-align:center;'>Рис. 4.6. Трассировка SMTP-сеанса с 
  включением обмена по протоколам DNS и TCP</p>
<p style='text-align:justify;'>Это номер запроса, используемый функциями разрешения 
  имен на bsd для сопоставления ответов с запросами. Знак «+» означает, что функция 
  разрешения задает опрос DNS-сервером других серверов, если у него нет информации 
  об ответе. Строка «MX?» показывает, что это запрос о записи почтового обмена 
  для сети, имя которой стоит в следующем поле (gte.net). Строка «(25)» свидетельствует 
  о том, что длина запроса - 25 байт.</p>
<p style='text-align:justify;'>Строка 2 - это ответ на запрос в строке 1. Число 
  45801 - это номер запроса, к которому относится ответ. Следующие три поля, разделенные 
  косой чертой, - количество записей в ответе, записей от сервера имен (полномочного 
  агента) и прочих записей. Строка «(371)» показывает, что ответ содержит 371 
  байт. И, наконец, строка «(DF)» означает, что в IP-заголовке ответа был поднят 
  бит «Don't fragment» (не фрагментировать). Итак, эти две строки иллюстрируют 
  использование системы DNS для поиска обработчиков почты (об этом кратко упоминалось 
  в совете 29).</p>
<p style='text-align:justify;'>Если в двух первых строках было выяснено имя обработчика 
  почты для сети gte.net, то в двух последующих выясняется его программа tcpdump 
  IP-адрес. «А?» в строке 3 указывает, что это запрос IP-адреса хоста mtapop2.gte.net 
  - одного из почтовых серверов компании GTE.</p>
<p style='text-align:justify;'>Строки 5-28 содержат детали обмена по протоколу 
  SMTP. Процедура трехстороннего квитирования между хостами bsd и mtapop2 начинается 
  в строке 5 и заканчивается строкой 7. Первое поле после временного штампа и 
  имен хостов - это поле flags. «S» в строке 5 указывает, что в сегменте установлен 
  флаг SYN. Другие возможные значения флага: «F» (FIN), «U» (URG), «P» (PUSH), 
  «R» (RST) и «.» (нет флагов). Далее идут порядковые номера первого и последнего 
  байтов, а за ними в скобках - число байтов данных. Эти поля могут вызвать некоторое 
  недоумение, так как «порядковый номер последнего» - это первый неиспользованный 
  порядковый номер, но только в том случае, когда в пакете есть данные. Удобнее 
  всего считать, что первое число - это порядковый номер первого байта в сегменте 
  (SYN или информационном), а второе - порядковый номер первого байта плюс число 
  байтов данных в сегменте. Следует отметить, что по умолчанию показываются реальные 
  порядковые номера для SYN-сегментов и смещения - для последующих сегментов (так 
  удобнее следить). Это поведение можно изменить с помощью опции - S в командной 
  строке.</p>
<p style='text-align:justify;'>Во всех сегментах, кроме первого SYN, имеется поле 
  АСК, показывающее, какой следующий порядковый номер ожидает отправитель. Это 
  поле (в виде ack nnn), как и раньше, по умолчанию содержит смещение относительно 
  порядкового номера, указанного в сегменте SYN.</p>
<p style='text-align:justify;'>За полем АСК идет поле window. Это количество байтов 
  данных, которое готов принять удаленный хост. Обычно оно отражает объем свободной 
  памяти в буферах соединения.</p>
<p style='text-align:justify;'>И, наконец, в угловых скобках указаны опции TCP. 
  Основные опции рассматриваются в RFC 793 [Postel 1981b] и RFC 1323 [Jacobson 
  et al. 1992]. Они обсуждаются также в книге [Stevens 1994], а их полный перечень 
  можно найти на Web-странице http://www.isi.edu/in-notes/iana/assignments/tcp-parameters.</p>
<p style='text-align:justify;'>В строках 8-23 показан диалог между программой 
  sendmail на bsd и SMTP сервером на машине mtapop2. Большая часть этих строк 
  опущена. Строки 24-28 отражают процедуру разрыва соединения. Сначала bsd посылает 
  FIN в строке 24 затем приходит FIN от mtapop2 (строка 25). Заметьте, что в строке 
  27 mtapop повторно посылает FIN. Это говорит о том, что хост не получил от bsd 
  подтверждения АСК на свой первый FIN, и еще раз подчеркивает важность состояния 
  ТIME-WAIT (совет 22).</p>
<p style='text-align:justify;'>Теперь посмотрим, что происходит при обмене UDP-датаграммами. 
  С помощью клиента udphelloc (совет 4) следует послать один нулевой байт в порт 
  сервера времени дня в домене netсоm.com:</p>
<p style='text-align:justify'>bsd: $ udphelloc netcom4.netcom.com daytime</p>
<p style='text-align:justify'>Thu Sep 16 15:11:49 1999</p>
<p style='text-align:justify'>bsd: $</p>
<p style='text-align:justify;'>Хост netcom4 возвращает дату и время в UDP-датаграмме. 
  Программа tcpdump печатает следующее:</p>
<p style='text-align:justify'>18:12:23.130009 bsd.1127 &gt; nectom4.netcom.com.daytime: 
  udp 1</p>
<p style='text-align:justify'>18:12:23.389284 nectom4.netcom.com.daytime &gt; 
  bsd.1127: udp 26</p>
<p style='text-align:justify;'>Отсюда видно, что bsd послал netcom4 UDP-датаграмму 
  длиной один байт, a netcom4 ответил датаграммой длиной 26 байт.</p>
<p style='text-align:justify;'>Протокол обмена ICMP-пакетами аналогичен. Ниже 
  приведена трассировка одного запроса, генерируемого программой ping с хоста 
  bsd на хост netcom4:</p>
<p style='text-align:justify'>1 06:21:28.690390 bsd &gt; netcom4.netcom.com: icmp: 
  echo request</p>
<p style='text-align:justify'>2 06:21:29.400433 netcom4.netcom.com &gt; bsd: icmp: 
  echo reply</p>
<p style='text-align:justify;'>Строка icmp: означает, что это ICMP-датаграмма, 
  а следующий за ней текст описывает тип этой датаграммы.</p>
<p style='text-align:justify;'>Один из недостатков tcpdump - это неполная поддержка 
  вывода собственно данных. Часто во время отладки сетевых приложений необходимо 
  знать, какие данные посылаются. Эту информацию можно получить, задав в командной 
  строке опции -s и -х, но данные будут выведены только в шестнадцатеричном формате. 
  Опция -х показывает, что содержимое пакета нужно выводить в шестнадцатерич­ном 
  виде. Опция -s сообщает, сколько данных из пакета выводить. По умолчанию tcpdump 
  выводит только первые 68 байт (в системе SunOS NIT - 96 байт). Этого достаточно 
  для заголовков большинства протоколов. Повторим предыдущий при­мер, касающийся 
  UDP, но здесь нужно выводить также следующие данные:</p>
<p style='text-align:justify'>tcpdump -х -s 100 -l</p>
<p style='text-align:justify;'>После удаления строк, относящихся к DNS, и исключения 
  имени домена из адреса хоста bsd получается следующий результат:</p>
<p style='text-align:justify'>1 12:57:53.299924 bsd.1053 &gt; netcom4.netcom.com.daytime: 
  udp 1</p>
<p style='text-align:justify;'>4500 001d 03d4 0000 4011 17al c7b7 c684</p>
<p style='text-align:justify;'>c7b7 0968 041d 000d 0009 9c56 00</p>
<p style='text-align:justify'>2 12:57:53.558921 netcom4.netcom.com.daytime &gt; 
  bsd.1053: udp 26</p>
<p style='text-align:justify;'>4500 0036 f0c8 0000 3611 3493 c7b7 0968</p>
<p style='text-align:justify;'>c7b7 c684 000d 041d 0022 765a 5375 6e20</p>
<p style='text-align:justify;'>5365 7020 3139 2030 393a 3537 3a34 3220</p>
<p style='text-align:justify;'>3139 3939 0a0d</p>
<p style='text-align:justify;'>Последний байт в первом пакете - это нулевой байт, 
  который udphelloc посылает хосту netcom4. Последние 26 байт второго пакета - 
  это полученный ответ. Интерпретировать приведенные в нем шестнадцатеричные цифры 
  довольно трудно.</p>
<p style='text-align:justify;'>Авторы tcpdump не хотели давать ASCII-представление 
  данных, так как полагали, что это упростит кражу паролей для технически неподготовленных 
  лиц. Теперь многие считают, что широкое распространение программ для кражи паролей 
  сделало это опасение неактуальным. Поэтому есть основания полагать, что в последующие 
  версии tcpdump будет включена поддержка вывода в коде ASCII*.(* Начиная с версии 
  3.5 tcpdump позволяет выводить и ASCII-представление. Для этого надо одновременно 
  указать опции -X и -х. - Прим. автора.)</p>
<p style='text-align:justify;'>А пока многие сетевые программисты упражняются 
  в написании фильтр, преобразующих выдачу tcpdump в код ASCII. Несколько подобных 
  программ есть в Internet. Показанный в листинге 4.1 сценарий Perl запускает 
  tcpdump, перенаправляет ее вывод к себе и перекодирует данные в ASCII.</p>
<p style='text-align:justify'>Листинг 4.1. Perl-сценарий для фильтрации выдачи 
  tcpdump</p>
<p style='text-align:justify'><a href="source\tcpd">tcpd</a></p>
<p style='text-align:justify;'>1    #! /usr/bin/perl5</p>
<p style='text-align:justify;'>2    $tcpdump = &quot;/usr/sbin/tcpdump&quot;;</p>
<p style='text-align:justify;'>3    open( TCPD, &quot;$tcpdump 8ARGV |&quot; ) 
  ||</p>
<p style='text-align:justify;'>4    die &quot;не могу запустить tcpdump: \$!\\n&quot;;</p>
<p style='text-align:justify;'>5    $| = 1;</p>
<p style='text-align:justify;'>6    while ( &lt;TCPD&gt; )</p>
<p style='text-align:justify;'>7    {</p>
<p style='text-align:justify;'>8    if ( /^\t/ }</p>
<p style='text-align:justify;'>9    {</p>
<p style='text-align:justify;'>10     chop;</p>
<p style='text-align:justify;'>11     $str =  $_;</p>
<p style='text-align:justify;'>12     $str =~ tr / \t//d;</p>
<p style='text-align:justify;'>13     $str = pack &quot;H*&quot;  , $str;</p>
<p style='text-align:justify;'>14     $str =~ tr/\x0-\xlf\x7f-\xff/./;</p>
<p style='text-align:justify;'>15     printf &quot;\t%-40s\t%s\n&quot;, substr(   
  $_, 4 ), $str;</p>
<p style='text-align:justify;'>16   }</p>
<p style='text-align:justify;'>17   else</p>
<p style='text-align:justify;'>18   {</p>
<p style='text-align:justify;'>19     print;</p>
<p style='text-align:justify;'>20   }</p>
<p style='text-align:justify;'>21   }</p>
<p style='text-align:justify;'>Если еще раз прогнать последний пример, но вместо 
  tcpdump использоват tcpd, то получится следующее:</p>
<p style='text-align:justify'>1 12:58:56.428052 bsd.1056 &gt; netcom4.netcom.com.daytime: 
  udp 1</p>
<p class=MsoBodyTextIndent>4500 OOld 03d7 0000 4011 179e c7b7 c684 E.......@.... 
</p>
<p style='text-align:justify;'>c7b7 0968 041d OOOd 0009 9c56 00 ..-h......S.</p>
<p style='text-align:justify'>2 12:58:56.717128 netcom4.netcom.com.daytime &gt; 
  bsd.1053: udp 26</p>
<p style='text-align:justify;'>4500 0036 lOfl 0000 3611 146b c7b7 0968  E..6....6..k..h</p>
<p style='text-align:justify;'>c7b7 c684 OOOd 0420 0022 7656 5375 6e20  .......&quot;rVSun</p>
<p style='text-align:justify;'>5365 7020 3139 2030 393a 3538 3a34 3620  Sep 19 
  09:58:46</p>
<p style='text-align:justify;'>3139 3939 OaOd                         1999..</p>
<h3><a name="p4">Резюме</a></h3>
<p style='text-align:justify;'>Программа tcpdump - это незаменимый инструмент 
  для изучения того, что происходит в сети. Если знать, что в действительности 
  посылается или принимается «по проводам», то трудные, на первый взгляд, ошибки 
  удается легко найти и исправить. Эта программа представляет собой также важный 
  инструмент для исследований динамики сети, а равно средство обучения. В последнем 
  качестве она широко при­меняется в книгах серии «TCP/IP Illustrated», написанных 
  Стивенсом.</p>
<hr><div align="right"><a href="adv34.htm#top">Вверх</a> | <a href="index.htm">Содержание</a> | <a href="adv33.htm">Назад</a> | <a href="adv35.htm">Далее</a></div>
</body>
</html>
