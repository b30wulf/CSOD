<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<link href="style.css" type="text/css" rel=stylesheet>
<title>Совет 28</title>
</head>
<body lang=RU link=blue vlink=purple class="Normal" bgcolor="#FFFFFF">
<h2><a name="top">Совет 28. Не забывайте о порядке байтов</a></h2>
<hr><div align="right"><a href="adv28.htm#p1">Вниз</a> | <a href="index.htm">Содержание</a> | <a href="adv27.htm">Назад</a> | <a href="adv29.htm">Далее</a></div>
<p style='text-align:justify;'>В современных компьютерах целые числа хранятся 
  по-разному, в зависимости от архитектуры. Рассмотрим 32-разрядное число 305419896 
  (0x12345678). Четыре байта этого числа могут храниться двумя способами: сначала 
  два старших байта {такой порядок называется тупоконечным - big endian)</p>
<p style='text-align:justify'>12 34   56   78</p>
<p style='text-align:justify;'>или сначала два младших байта (такой порядок называется 
  остроконечным - little endian)</p>
<p style='text-align:justify;'>78 56   34   12</p>
<p style='text-align:justify;'><i>Примечание:</i> Термины «тупоконечный» и «остроконечный» 
  ввел Коэн [Cohen П1981], считавший, что споры о том, какой формат лучше, сродни 
  распрям лилипутов из романа Свифта «Путешествия Гулливера», которые вели бесконечные 
  войны, не сумев договориться, с какого конца следует разбивать яйцо — с тупого 
  или острого. Раньше были в ходу и другие форматы, но практически во все современных 
  машинах применяется либо тупоконечный, либо остроконечный порядок байтов.</p>
<p style='text-align:justify;'>Определить формат, применяемый в конкретной машине, 
  можно с помощью следующей текстовой программы, показывающей, как хранится число 
  0х12345б78 (листинг 3.34).</p>
<p style='text-align:justify;'>Листинг 3.34. Программа для определения порядка 
  байтов</p>
<p style='text-align:justify'>endian.c</p>
<p style='text-align:justify;'>1    #include &lt;stdio.h&gt;</p>
<p style='text-align:justify;'>2    #include &lt;sys/types.h&gt;</p>
<p style='text-align:justify;'>3    #include &quot;etcp.h&quot;</p>
<p style='text-align:justify;'>4    int main( void )</p>
<p style='text-align:justify;'>5    {</p>
<p style='text-align:justify;'>6    u_int32_t x = 0x12345678;   /* 305419896 */</p>
<p style='text-align:justify;'>7    unsigned char *xp = ( char * )&amp;x;</p>
<p style='text-align:justify;'>9    printf( &quot;%0x %0x %0x %0x\n&quot;,</p>
<p style='text-align:justify;'>10   xp[ 0 ], xp[ 1 ], xp[ 2 ], xp[ 3 ] );</p>
<p style='text-align:justify;'>11   exit(   0   );</p>
<p style='text-align:justify;'>12   }</p>
<p style='text-align:justify;'>Если запустить эту программу на компьютере с процессором 
  Intel, то получится:</p>
<p style='text-align:justify;'>bsd:   $  endian</p>
<p style='text-align:justify;'>78   56   34   12</p>
<p style='text-align:justify;'>bsd:    $</p>
<p style='text-align:justify;'>Отсюда ясно видно, это - остроконечная архитектура.</p>
<p style='text-align:justify;'>Конкретный формат хранения иногда в шутку называют 
  полом байтов. Он важен, поскольку остроконечные и тупоконечные машины (а равно 
  те, что используют иной порядок) часто общаются друг с другом по протоколам 
  TCP/IP- Поскольку такая информация, как адреса отправления и назначения, номера 
  портов, длина датаграмм, размеры окон и т.д., представляется в виде целых чисел, 
  необходимо, чтобы обе стороны интерпретировали их одинаково.</p>
<p style='text-align:justify;'>Чтобы обеспечить взаимодействие компьютеров с разными 
  архитектурами» все целочисленные величины, относящиеся к протоколам, передаются 
  в сетевом порядке байтов, который по определению является тупоконечным. По большей 
  части, обо всем заботятся сами протоколы, но сетевые адреса, номера портов, 
  а иногда и другие данные, представленные в заголовках, вы задаете сами. И всякий 
  раз необходимо преобразовывать их в сетевой порядок.</p>
<p style='text-align:justify;'>Для этого служат две функции, занимающиеся преобразованием 
  из машинного порядка байт в сетевой и обратно. Представленные ниже объявления 
  этих функций заимствованы из стандарта POSIX. В некоторых версиях UNIX эти объявления 
  находятся не в файле netinet/in.h. Типы uint32_t и uint16_t приняты в POSIX 
  соответственно для без знаковых 32- и 16-разрядных целых. В некоторых реализациях 
  эти типы могут отсутствовать. Тем не менее функции htonl и ntohl всегда принимают 
  и возвращают беззнаковые 32-разрядные целые числа, будь то UNIX или Winsock. 
  Точно так же функции htons и ntohs всегда принимают и возвращают беззнаковые 
  16-разрядные целые.</p>
<p style='text-align:justify;'><i>Примечание:</i> Буквы «l» и «s» в конце имен 
  функций означают long (длинное) и short (короткое). Это имело смысл, так как 
  первоначально данные функции появились в системе 4.2BSD, разработанной для 32-разрядной 
  машины, где длинное целое принимали равным 32 бит, а короткое - 16. С появлением 
  64-разрядных машин это уже не так важно, поэтому следует помнить, что 1-функции 
  работают с 32-разрядными числами, которые не обязательно представлены как long, 
  а s-функции - с 16разрядными числами, которые не обязательно представлены в 
  виде short. Удобно считать, что 1-функции предназначены для преобразования длинных 
  полей в заголовках протокола, а s-функции - коротких полей.</p>
<div style='border:solid windowtext .5pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'> 
  <p style='text-align:justify;border:none;padding:0cm;'>#include  &lt;netinet/in.h&gt;    
    /*  UNIX   */</p>
  <p style='text-align:justify;border:none;padding:0cm;'>#include  &lt;winsock2 
    .h&gt; /*  Winsock  */</p>
  <p style='text-align:justify;border:none;padding:0cm;'>uint32_t  htonl(   uint32_t  
    host32   );</p>
  <p style='text-align:justify;border:none;padding:0cm;'>uint16_t  htons(   uint16_t  
    host16  );</p>
  <p style='text-align:justify;border:none;padding:0cm;'>Обе функции возвращают 
    целое число в сетевом порядке.</p>
  <p style='text-align:justify;border:none;padding:0cm;'>uint32_t  ntohl(   uint32_t  
    network32   ) ;</p>
  <p style='text-align:justify;border:none;padding:0cm;'>uint16_t  ntohs(   uint16_t  
    network16  );</p>
  <p style='text-align:justify;border:none;padding:0cm;'>Обе функции возвращают 
    целое число в машинном порядке.</p>
</div>
<p style='text-align:justify;'>Функции htonl и htons преобразуют целое число из 
  машинного порядка байт в сетевой, тогда как функции ntohl и ntohs выполняют 
  обратное преобразова­ние. Заметим, что на «тупоконечных» машинах эти функции 
  ничего не делают И обычно определяются в виде макросов:</p>
<p style='text-align:justify'>#define htonl(x)   (x)</p>
<p style='text-align:justify;'>На «остроконечных» машинах (и для иных архитектур) 
  реализация функций зависит от системы. Не надо задумываться, на какой машине 
  вы работаете, по­скольку эти функции всегда делают то, что нужно.</p>
<p style='text-align:justify;'>Применение этих функций обязательно только для 
  полей, используемых протоколами. Пользовательские данные для протоколов IP, 
  UDP и TCP выглядят как множество неструктурированных байтов, так что неважно, 
  записаны целые числа в сетевом или машинном порядке. Тем не менее функции ntoh* 
  и hton* стоит применять при передаче любых данных, поскольку тем самым вы обеспечиваете 
  возможность совместной работы машин с разной архитектурой. Даже если сначала 
  предполагается, что приложение будет работать только на одной платформе обязательно 
  настанет день, когда его придется переносить на другую платформу. Тогда дополнительные 
  усилия окупятся с лихвой.</p>
<p style='text-align:justify;'><i>Примечание:</i> В общем случае проблема преобразования 
  данных между машинами с разными архитектурами сложна. Многие программисты решают 
  ее, преобразуя все числа в код ASCII (или, возможно, в код EBCDIC для больших 
  машин фирмы IBM). Другой подход связан с использованием компоненты XDR (External 
  Data Representation -внешнее представление данных), входящей в состав подсистемы 
  вызова удаленных процедур (RFC - remote procedure call), разработанной фирмой 
  Sun. Компонента XDR определена в RFC 1832 [Srinivasan 1995] и представляет собой 
  набор правил для кодирования данных различных типов, а также язык, описывающий 
  способ кодирования. Хотя предполагалось, что XDR будет применяться как часть 
  RPC, можно пользоваться этим механизмом в ваших программах. В книге [Stevens 
  1999] обсуждается XDR и его применение без RPC.</p>
<p style='text-align:justify;'>И, наконец, следует помнить, что функции разрешения 
  имен, такие как gethostbyname и getservbyname (совет 29), возвращают значения, 
  представ­ленные в сетевом порядке. Поэтому следующий неправильный код</p>
<p style='text-align:justify'>struct  servant   *sp;</p>
<p style='text-align:justify'>struct  sockaddr_in  *sap;</p>
<p style='text-align:justify'>sp  = getservbyname(  name,   protocol   );</p>
<p style='text-align:justify'>sap-&gt;sin_port  =  htons(   sp-&gt;s_port   );</p>
<p style='text-align:justify'>приведет к ошибке, если исполняется не на «тупоконечной» 
  машине.</p>
<h3><a name="p1">Резюме</a></h3>
<p style='text-align:justify;'>В этом разделе рассказывалось, что в TCP/IP применяется 
  стандартное представление в сетевом порядке байт для целых чисел, входящих в 
  заголовки прото колов. Здесь также приведены функции htonl, htons, ntohl и ntohs, 
  которь преобразуют целые из машинного порядка байт в сетевой и обратно. Кроме 
  того. было отмечено, что в общем случае для преобразования форматов данных между 
  машинами полезно средство XDR.</p>
<hr><div align="right"><a href="adv28.htm#top">Вверх</a> | <a href="index.htm">Содержание</a> | <a href="adv27.htm">Назад</a> | <a href="adv29.htm">Далее</a></div>
</body>
</html>
